<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LINEã‚¹ã‚¿ãƒ³ãƒ—ä¸€æ‹¬ç”Ÿæˆãƒ„ãƒ¼ãƒ« (AIç‰ˆ)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Noto Sans JP', sans-serif;
            background-color: #f0fdf4;
        }

        .canvas-container {
            background-image:
                linear-gradient(45deg, #e5e7eb 25%, transparent 25%),
                linear-gradient(-45deg, #e5e7eb 25%, transparent 25%),
                linear-gradient(45deg, transparent 75%, #e5e7eb 75%),
                linear-gradient(-45deg, transparent 75%, #e5e7eb 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
        }

        /* Loading Animation */
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #16a34a;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
            display: inline-block;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="text-gray-800 min-h-screen flex flex-col">

    <header class="bg-green-600 text-white p-4 shadow-md">
        <div class="container mx-auto flex justify-between items-center">
            <h1 class="text-xl font-bold flex items-center gap-2">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
                    stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
                    style="width: 24px; height: 24px;">
                    <path
                        d="M12 2a10 10 0 1 0 10 10A10 10 0 0 0 12 2zm0 14a1 1 0 1 1 0-2 1 1 0 0 1 0 2zm0-4a1 1 0 0 1-1-1V7a1 1 0 0 1 2 0v4a1 1 0 0 1-1 1z" />
                </svg>
                LINEã‚¹ã‚¿ãƒ³ãƒ—ç”Ÿæˆ
            </h1>
            <a href="https://creator.line.me/ja/guideline/sticker/" target="_blank"
                class="text-xs bg-white text-green-600 px-3 py-1 rounded-full hover:bg-green-100 transition">åˆ¶ä½œã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³</a>
        </div>
    </header>

    <main class="container mx-auto p-4 flex-grow max-w-5xl">



        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">

            <div class="lg:col-span-1 space-y-6">

                <!-- 1. ç”»åƒé¸æŠ -->
                <div class="bg-white p-6 rounded-lg shadow">
                    <label class="block text-sm font-bold mb-2 text-gray-700">1. ç”»åƒã‚’é¸æŠ</label>
                    <div class="relative border-2 border-dashed border-gray-300 rounded-lg p-6 hover:bg-gray-50 transition text-center cursor-pointer"
                        id="dropZone">
                        <input type="file" id="imageInput" accept="image/png, image/jpeg"
                            class="absolute inset-0 w-full h-full opacity-0 cursor-pointer z-10">
                        <div class="space-y-2 pointer-events-none">
                            <svg class="mx-auto h-12 w-12 text-gray-400" stroke="currentColor" fill="none"
                                viewBox="0 0 48 48" style="width: 48px; height: 48px;">
                                <path
                                    d="M28 8H12a4 4 0 00-4 4v20m32-12v8m0 0v8a4 4 0 01-4 4H12a4 4 0 01-4-4v-4m32-4l-3.172-3.172a4 4 0 00-5.656 0L28 28M8 32l9.172-9.172a4 4 0 015.656 0L28 28m0 0l4 4m4-24h8m-4-4v8m-12 4h.02"
                                    stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
                            </svg>
                            <p class="text-sm text-gray-600">ã‚¯ãƒªãƒƒã‚¯ã¾ãŸã¯D&D</p>
                        </div>
                    </div>
                </div>

                <!-- 2. åˆ†å‰²è¨­å®š -->
                <div class="bg-white p-6 rounded-lg shadow">
                    <div class="flex justify-between items-end mb-4">
                        <label class="block text-sm font-bold text-gray-700">2. åˆ†å‰²è¨­å®š</label>
                        <button id="dlTemplateBtn"
                            class="text-xs bg-blue-100 text-blue-600 px-2 py-1 rounded hover:bg-blue-200 transition">ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆDL</button>
                    </div>

                    <div class="grid grid-cols-2 gap-4 mb-4">
                        <div>
                            <label class="block text-xs text-gray-500 mb-1">æ¨ª (Cols)</label>
                            <input type="number" id="colInput" value="4" min="1" max="10"
                                class="w-full border border-gray-300 rounded px-3 py-2 outline-none">
                        </div>
                        <div>
                            <label class="block text-xs text-gray-500 mb-1">ç¸¦ (Rows)</label>
                            <input type="number" id="rowInput" value="4" min="1" max="10"
                                class="w-full border border-gray-300 rounded px-3 py-2 outline-none">
                        </div>
                    </div>

                    <div class="mb-4">
                        <label class="block text-xs text-gray-500 mb-1">ãƒ¡ã‚¤ãƒ³/ã‚¿ãƒ–ç”»åƒ</label>
                        <select id="mainImageIndex" class="w-full border border-gray-300 rounded px-3 py-2 text-sm">
                            <option value="0">1ç•ªç›® (å·¦ä¸Š)</option>
                        </select>
                    </div>
                </div>

                <!-- 3. èƒŒæ™¯é€éè¨­å®š -->
                <div class="bg-white p-6 rounded-lg shadow space-y-4">
                    <label class="block text-sm font-bold text-gray-700">3. èƒŒæ™¯é€éè¨­å®š</label>

                    <!-- è‰²æŒ‡å®šãƒ¢ãƒ¼ãƒ‰è¨­å®š -->
                    <div id="panelColor" class="space-y-3">
                        <div class="flex items-center gap-2">
                            <input type="checkbox" id="autoRemoveBg" checked
                                class="w-5 h-5 text-green-600 rounded focus:ring-green-500 cursor-pointer">
                            <label for="autoRemoveBg"
                                class="text-sm font-bold text-gray-800 cursor-pointer select-none">
                                èƒŒæ™¯ã‚’è‡ªå‹•é™¤å»
                            </label>
                        </div>
                        <p class="text-xs text-gray-500 ml-7">
                            ç”»åƒã®å››éš…ã‹ã‚‰ç¹‹ãŒã£ã¦ã„ã‚‹èƒŒæ™¯è‰²ã‚’è‡ªå‹•ã§æ¶ˆã—ã¾ã™ã€‚
                        </p>

                        <div class="ml-7 pt-2">
                            <label class="block text-xs text-gray-500 mb-1">è‰²ã®è¨±å®¹ç¯„å›²(ã‚ã„ã¾ã„ã•): <span
                                    id="toleranceVal">20</span></label>
                            <input type="range" id="toleranceRange" min="0" max="100" value="20"
                                class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                        </div>

                        <div class="bg-yellow-50 p-3 rounded border border-yellow-200 text-xs text-yellow-800 mt-2">
                            <span class="font-bold">ğŸ’¡ ãƒ’ãƒ³ãƒˆ:</span> ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ç”»åƒã‚’ã‚¯ãƒªãƒƒã‚¯ã™ã‚‹ã¨ã€ãã®éƒ¨åˆ†ã®è‰²ã‚’é€æ˜ã«ã§ãã¾ã™(æ–‡å­—ã®ä¸­ãªã©ã«ä¾¿åˆ©)ã€‚
                        </div>

                        <div class="flex justify-end">
                            <button id="undoBtn" disabled
                                class="text-xs flex items-center gap-1 bg-gray-100 px-3 py-1.5 rounded hover:bg-gray-200 disabled:opacity-50 transition">
                                <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24"
                                    fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                    stroke-linejoin="round">
                                    <path d="M3 7v6h6" />
                                    <path d="M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3L3 13" />
                                </svg>
                                å…ƒã«æˆ»ã™
                            </button>
                        </div>
                    </div>

                    <hr class="border-gray-100">

                    <div class="flex items-start gap-2 pt-2">
                        <input type="checkbox" id="autoCenter" checked
                            class="mt-1 w-4 h-4 text-green-600 border-gray-300 rounded focus:ring-green-500 cursor-pointer">
                        <label for="autoCenter" class="text-sm text-gray-700 cursor-pointer select-none">
                            <span class="font-bold block">è‡ªå‹•ãƒˆãƒªãƒŸãƒ³ã‚°ï¼†ä¸­å¤®æƒãˆ</span>
                            <span class="text-xs text-gray-500 leading-tight">ä½™ç™½ã‚’ã‚«ãƒƒãƒˆã—ã¦ä¸­å¤®ã«é…ç½®ã—ã¾ã™ã€‚</span>
                        </label>
                    </div>
                </div>

                <button id="generateBtn" disabled
                    class="w-full bg-green-600 text-white font-bold py-3 px-4 rounded shadow-lg hover:bg-green-700 disabled:bg-gray-400 disabled:cursor-not-allowed transition flex justify-center items-center gap-2">
                    <span id="btnText">å¤‰æ›ï¼†ZIPä½œæˆ</span>
                </button>
                <div id="statusContainer" class="hidden text-center" style="display: none;">
                    <div class="loader mb-2"></div>
                    <div id="statusMsg" class="text-sm font-semibold text-green-700">å‡¦ç†ä¸­...</div>
                </div>

            </div>

            <div class="lg:col-span-2">
                <div class="bg-white p-4 rounded-lg shadow h-full flex flex-col">
                    <h3 class="text-sm font-bold text-gray-700 mb-2 flex justify-between items-center">
                        ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ & é€éç·¨é›†
                        <span class="text-xs font-normal text-gray-500">ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã§ç”»åƒã‚’é¸æŠ / ã‚¯ãƒªãƒƒã‚¯ã§é€é</span>
                    </h3>
                    <div class="flex-grow canvas-container relative border rounded bg-gray-50 overflow-hidden flex items-center justify-center min-h-[400px]"
                        id="previewContainer">
                        <p class="text-gray-400 text-sm pointer-events-none">ç”»åƒãŒã“ã“ã«è¡¨ç¤ºã•ã‚Œã¾ã™</p>
                        <!-- Canvas for editing -->
                        <canvas id="editorCanvas"
                            class="hidden max-w-full max-h-full object-contain z-10 cursor-crosshair"></canvas>
                        <div id="gridOverlay"
                            class="absolute top-0 left-0 pointer-events-none z-20 border-collapse border border-red-500 hidden">
                        </div>
                    </div>
                </div>
            </div>

        </div>
    </main>

    <script>
        // DOM Elements
        const imageInput = document.getElementById('imageInput');
        const dropZone = document.getElementById('dropZone');
        const gridOverlay = document.getElementById('gridOverlay');
        const colInput = document.getElementById('colInput');
        const rowInput = document.getElementById('rowInput');
        const generateBtn = document.getElementById('generateBtn');
        const btnText = document.getElementById('btnText');
        const statusMsg = document.getElementById('statusMsg');
        const statusContainer = document.getElementById('statusContainer');
        const mainImageIndex = document.getElementById('mainImageIndex');
        const previewContainer = document.getElementById('previewContainer');
        const autoCenterCheckbox = document.getElementById('autoCenter');
        const dlTemplateBtn = document.getElementById('dlTemplateBtn');

        // Elements for Color Removal
        const editorCanvas = document.getElementById('editorCanvas');
        const autoRemoveBgCheckbox = document.getElementById('autoRemoveBg');
        const toleranceRange = document.getElementById('toleranceRange');
        const toleranceVal = document.getElementById('toleranceVal');
        const undoBtn = document.getElementById('undoBtn');

        let originalImage = null;
        let history = []; // Undo history
        let ctx = null; // Editor canvas context
        let cellCheckStates = []; // Checkbox states for each grid cell

        // Constants
        const SPECS = {
            sticker: { w: 370, h: 320, margin: 10 },
            main: { w: 240, h: 240 },
            tab: { w: 96, h: 74 }
        };

        // Event Listeners
        if (imageInput) imageInput.addEventListener('change', handleFileSelect);
        if (colInput) colInput.addEventListener('input', updateGrid);
        if (rowInput) rowInput.addEventListener('input', updateGrid);
        window.addEventListener('resize', updateGridUI);
        if (generateBtn) generateBtn.addEventListener('click', generateZip);
        if (dlTemplateBtn) dlTemplateBtn.addEventListener('click', downloadTemplate);



        // Color Removal Controls
        toleranceRange.addEventListener('input', (e) => toleranceVal.innerText = e.target.value);
        autoRemoveBgCheckbox.addEventListener('change', applyAutoRemoval);
        undoBtn.addEventListener('click', undo);

        // Canvas Interaction
        editorCanvas.addEventListener('click', handleCanvasClick);

        const resizeObserver = new ResizeObserver(() => updateGridUI());
        if (previewContainer) resizeObserver.observe(previewContainer);

        // Drag and Drop
        if (dropZone) {
            dropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropZone.classList.add('bg-green-50', 'border-green-400');
            });
            dropZone.addEventListener('dragleave', () => {
                dropZone.classList.remove('bg-green-50', 'border-green-400');
            });
            dropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                dropZone.classList.remove('bg-green-50', 'border-green-400');
                if (e.dataTransfer.files.length > 0) {
                    imageInput.files = e.dataTransfer.files;
                    handleFileSelect({ target: imageInput });
                }
            });
        }



        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function (e) {
                originalImage = new Image();
                originalImage.onload = function () {
                    // Setup Canvas
                    editorCanvas.width = originalImage.width;
                    editorCanvas.height = originalImage.height;
                    ctx = editorCanvas.getContext('2d', { willReadFrequently: true });

                    resetCanvas();

                    editorCanvas.classList.remove('hidden');
                    previewContainer.querySelector('p')?.remove();

                    // Initial Auto Removal
                    if (autoRemoveBgCheckbox.checked) {
                        applyAutoRemoval();
                    }

                    updateGrid();
                    updateSelectOptions();
                    generateBtn.disabled = false;
                }
                originalImage.src = e.target.result;
            }
            reader.readAsDataURL(file);
        }

        function resetCanvas() {
            if (!ctx || !originalImage) return;
            ctx.clearRect(0, 0, editorCanvas.width, editorCanvas.height);
            ctx.drawImage(originalImage, 0, 0);
            saveState();
            history = [ctx.getImageData(0, 0, editorCanvas.width, editorCanvas.height)]; // Reset history
            updateUndoBtn();
        }

        function saveState() {
            if (!ctx) return;
            if (history.length > 10) history.shift(); // Limit history
            history.push(ctx.getImageData(0, 0, editorCanvas.width, editorCanvas.height));
            updateUndoBtn();
        }

        function undo() {
            if (history.length <= 1) return;
            history.pop(); // Remove current state
            const prevState = history[history.length - 1];
            ctx.putImageData(prevState, 0, 0);
            updateUndoBtn();
        }

        function updateUndoBtn() {
            undoBtn.disabled = history.length <= 1;
            undoBtn.style.opacity = history.length <= 1 ? '0.5' : '1';
        }

        function applyAutoRemoval() {
            if (!ctx || !autoRemoveBgCheckbox.checked) {
                resetCanvas();
                return;
            }
            // Reset first
            ctx.drawImage(originalImage, 0, 0);

            // Remove corners
            const corners = [
                { x: 0, y: 0 },
                { x: editorCanvas.width - 1, y: 0 },
                { x: 0, y: editorCanvas.height - 1 },
                { x: editorCanvas.width - 1, y: editorCanvas.height - 1 }
            ];

            const tolerance = parseInt(toleranceRange.value);

            // Process corners
            corners.forEach(p => {
                floodFill(p.x, p.y, tolerance);
            });
            saveState();
        }

        function handleCanvasClick(e) {
            if (currentMode !== 'color' || !ctx) return;

            const rect = editorCanvas.getBoundingClientRect();
            const scaleX = editorCanvas.width / rect.width;
            const scaleY = editorCanvas.height / rect.height;

            const x = Math.floor((e.clientX - rect.left) * scaleX);
            const y = Math.floor((e.clientY - rect.top) * scaleY);

            const tolerance = parseInt(toleranceRange.value);
            floodFill(x, y, tolerance);
            saveState();
        }

        // Flood Fill Algorithm (Queue-based)
        function floodFill(startX, startY, tolerance) {
            const width = editorCanvas.width;
            const height = editorCanvas.height;
            const imageData = ctx.getImageData(0, 0, width, height);
            const data = imageData.data;

            const startPos = (startY * width + startX) * 4;
            const startR = data[startPos];
            const startG = data[startPos + 1];
            const startB = data[startPos + 2];
            const startA = data[startPos + 3];

            if (startA === 0) return; // Already transparent

            const queue = [[startX, startY]];
            const visited = new Uint8Array(width * height); // Track visited pixels

            while (queue.length > 0) {
                const [x, y] = queue.pop();
                const pos = (y * width + x) * 4;

                if (visited[y * width + x]) continue;

                // Check color match
                const r = data[pos];
                const g = data[pos + 1];
                const b = data[pos + 2];
                const a = data[pos + 3];

                if (a === 0) continue; // Skip if already transparent

                const diff = Math.abs(r - startR) + Math.abs(g - startG) + Math.abs(b - startB);

                // Tolerance check (simple sum of diffs < tolerance * 3)
                if (diff <= tolerance * 3) {
                    // Make transparent
                    data[pos + 3] = 0;
                    visited[y * width + x] = 1;

                    // Add neighbors
                    if (x > 0) queue.push([x - 1, y]);
                    if (x < width - 1) queue.push([x + 1, y]);
                    if (y > 0) queue.push([x, y - 1]);
                    if (y < height - 1) queue.push([x, y + 1]);
                }
            }

            ctx.putImageData(imageData, 0, 0);
        }

        function updateGrid() {
            if (!originalImage) return;
            updateGridUI();
            updateSelectOptions();
        }

        function updateGridUI() {
            if (!editorCanvas.width || editorCanvas.classList.contains('hidden')) return;

            const cols = parseInt(colInput.value) || 1;
            const rows = parseInt(rowInput.value) || 1;

            // Match overlay to canvas display size
            const rect = editorCanvas.getBoundingClientRect();
            // Need to account for object-contain centering if parent is larger
            // But here editorCanvas is max-w-full, so rect should be accurate to the visible image

            // However, if the canvas is smaller than container, it might be centered.
            // We need to position the gridOverlay exactly over the canvas element.

            gridOverlay.style.width = `${editorCanvas.offsetWidth}px`;
            gridOverlay.style.height = `${editorCanvas.offsetHeight}px`;
            gridOverlay.style.top = `${editorCanvas.offsetTop}px`;
            gridOverlay.style.left = `${editorCanvas.offsetLeft}px`;

            gridOverlay.classList.remove('hidden');
            gridOverlay.innerHTML = '';
            gridOverlay.style.display = 'grid';
            gridOverlay.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
            gridOverlay.style.gridTemplateRows = `repeat(${rows}, 1fr)`;

            const total = cols * rows;

            // Initialize checkbox states if needed
            if (cellCheckStates.length !== total) {
                cellCheckStates = new Array(total).fill(true);
            }

            for (let i = 0; i < total; i++) {
                const cell = document.createElement('div');
                cell.className = 'border border-red-500/50 flex items-start justify-between p-2 text-red-600 font-bold text-xs bg-red-100/10 hover:bg-red-100/30 transition relative';

                // Checkbox container
                const checkboxContainer = document.createElement('div');
                checkboxContainer.className = 'flex items-center gap-1 bg-white/90 rounded px-2 py-1 shadow-sm pointer-events-auto cursor-pointer';
                checkboxContainer.onclick = (e) => {
                    e.stopPropagation();
                    toggleCellCheck(i);
                };

                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.checked = cellCheckStates[i];
                checkbox.className = 'w-5 h-5 text-green-600 rounded focus:ring-green-500 cursor-pointer pointer-events-none';
                checkbox.id = `cell-check-${i}`;

                const label = document.createElement('label');
                label.htmlFor = `cell-check-${i}`;
                label.innerText = i + 1;
                label.className = 'cursor-pointer select-none pointer-events-none';

                checkboxContainer.appendChild(checkbox);
                checkboxContainer.appendChild(label);
                cell.appendChild(checkboxContainer);

                gridOverlay.appendChild(cell);
            }
        }

        function toggleCellCheck(index) {
            cellCheckStates[index] = !cellCheckStates[index];
            updateGridUI(); // Refresh UI
            updateSelectOptions(); // Update main image select options
        }

        function updateSelectOptions() {
            const cols = parseInt(colInput.value) || 1;
            const rows = parseInt(rowInput.value) || 1;
            const total = cols * rows;
            const currentSelection = mainImageIndex.value;
            mainImageIndex.innerHTML = '';

            for (let i = 0; i < total; i++) {
                // Only add checked cells
                if (cellCheckStates[i]) {
                    const option = document.createElement('option');
                    option.value = i;
                    option.text = `${i + 1}ç•ªç›®ã®ç”»åƒ`;
                    mainImageIndex.appendChild(option);
                }
            }

            // Try to maintain current selection if still checked
            if (currentSelection < total && cellCheckStates[currentSelection]) {
                mainImageIndex.value = currentSelection;
            }
        }

        // --- Logic ---

        function getContentBoundingBox(ctx, width, height) {
            const imgData = ctx.getImageData(0, 0, width, height);
            const data = imgData.data;
            let minX = width, minY = height, maxX = 0, maxY = 0, found = false;

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const i = (y * width + x) * 4;
                    if (data[i + 3] > 20) { // Alpha threshold
                        if (x < minX) minX = x;
                        if (x > maxX) maxX = x;
                        if (y < minY) minY = y;
                        if (y > maxY) maxY = y;
                        found = true;
                    }
                }
            }
            return found ? { x: minX, y: minY, w: maxX - minX + 1, h: maxY - minY + 1 } : null;
        }

        async function generateZip() {
            if (!originalImage) return;

            // UI State Update
            generateBtn.disabled = true;
            generateBtn.classList.add('hidden');
            statusContainer.classList.remove('hidden');
            statusContainer.style.display = 'block';
            statusMsg.innerText = "å‡¦ç†ã‚’é–‹å§‹ã—ã¾ã™...";
            statusMsg.className = "text-sm font-semibold text-green-700";

            try {
                let processImage;

                // Use the edited canvas as source
                processImage = new Image();
                processImage.src = editorCanvas.toDataURL();
                await new Promise(r => processImage.onload = r);

                statusMsg.innerText = "ã‚¹ã‚¿ãƒ³ãƒ—ç”»åƒã‚’åˆ†å‰²ãƒ»ç”Ÿæˆä¸­...";
                await new Promise(r => setTimeout(r, 100));

                const zip = new JSZip();
                const cols = parseInt(colInput.value);
                const rows = parseInt(rowInput.value);
                const totalCells = cols * rows;
                const cellW = processImage.naturalWidth / cols;
                const cellH = processImage.naturalHeight / rows;
                const selectedMainIndex = parseInt(mainImageIndex.value);
                const shouldAutoCenter = autoCenterCheckbox.checked;

                let outputIndex = 1; // Counter for output file names

                for (let i = 0; i < totalCells; i++) {
                    // Skip unchecked cells
                    if (!cellCheckStates[i]) continue;

                    const c = i % cols;
                    const r = Math.floor(i / cols);

                    // Cut cell
                    const rawCanvas = document.createElement('canvas');
                    rawCanvas.width = cellW;
                    rawCanvas.height = cellH;
                    const rawCtx = rawCanvas.getContext('2d');
                    rawCtx.drawImage(processImage, c * cellW, r * cellH, cellW, cellH, 0, 0, cellW, cellH);

                    // Determine Trim
                    let srcX = 0, srcY = 0, srcW = cellW, srcH = cellH;
                    if (shouldAutoCenter) {
                        const bbox = getContentBoundingBox(rawCtx, cellW, cellH);
                        if (bbox) {
                            srcX = bbox.x; srcY = bbox.y; srcW = bbox.w; srcH = bbox.h;
                        }
                    }

                    // Draw Final
                    const drawCentered = (targetCanvas, tW, tH, margin) => {
                        const tCtx = targetCanvas.getContext('2d');
                        const maxW = tW - (margin * 2);
                        const maxH = tH - (margin * 2);
                        const scale = Math.min(maxW / srcW, maxH / srcH);
                        const drawW = srcW * scale;
                        const drawH = srcH * scale;
                        tCtx.drawImage(rawCanvas, srcX, srcY, srcW, srcH, (tW - drawW) / 2, (tH - drawH) / 2, drawW, drawH);
                    };

                    // Sticker
                    const stickerCanvas = document.createElement('canvas');
                    stickerCanvas.width = SPECS.sticker.w;
                    stickerCanvas.height = SPECS.sticker.h;
                    drawCentered(stickerCanvas, SPECS.sticker.w, SPECS.sticker.h, SPECS.sticker.margin);
                    const fileName = `${outputIndex.toString().padStart(2, '0')}.png`;
                    zip.file(fileName, await new Promise(r => stickerCanvas.toBlob(r)));

                    // Main/Tab
                    if (i === selectedMainIndex) {
                        const mainCanvas = document.createElement('canvas');
                        mainCanvas.width = SPECS.main.w;
                        mainCanvas.height = SPECS.main.h;
                        drawCentered(mainCanvas, SPECS.main.w, SPECS.main.h, 0);
                        zip.file("main.png", await new Promise(r => mainCanvas.toBlob(r)));

                        const tabCanvas = document.createElement('canvas');
                        tabCanvas.width = SPECS.tab.w;
                        tabCanvas.height = SPECS.tab.h;
                        drawCentered(tabCanvas, SPECS.tab.w, SPECS.tab.h, 0);
                        zip.file("tab.png", await new Promise(r => tabCanvas.toBlob(r)));
                    }

                    outputIndex++; // Increment for next checked image
                }

                const content = await zip.generateAsync({ type: "blob" });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(content);
                link.download = "line_stickers.zip";
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);

                statusMsg.innerText = "å®Œäº†ã—ã¾ã—ãŸï¼";
                setTimeout(() => {
                    statusContainer.classList.add('hidden');
                    statusContainer.style.display = 'none';
                    generateBtn.classList.remove('hidden');
                    generateBtn.disabled = false;
                }, 2000);

            } catch (err) {
                console.error(err);
                statusMsg.innerText = "ã‚¨ãƒ©ãƒ¼: " + err.message;
                statusMsg.className = "text-sm font-bold text-red-600";
                generateBtn.classList.remove('hidden');
            }
        }

        function downloadTemplate() {
            const cols = parseInt(colInput.value) || 4;
            const rows = parseInt(rowInput.value) || 4;
            const cellW = 370;
            const cellH = 320;
            const canvas = document.createElement('canvas');
            canvas.width = cols * cellW;
            canvas.height = rows * cellH;
            const ctx = canvas.getContext('2d');

            ctx.fillStyle = "#ffffff";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = "#ff0000";
            ctx.lineWidth = 4;
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.font = "bold 30px 'Noto Sans JP', sans-serif";
            ctx.fillStyle = "#ff0000";

            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    const x = c * cellW;
                    const y = r * cellH;
                    ctx.strokeRect(x, y, cellW, cellH);
                    ctx.fillText(`${cellW} x ${cellH} px`, x + cellW / 2, y + cellH / 2);
                }
            }
            canvas.toBlob(blob => {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = `template_${cols}x${rows}.png`;
                link.click();
            });
        }
    </script>
</body>

</html>