<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LINEスタンプ分割＆背景透過</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Noto Sans JP', sans-serif;
            background-color: #f0fdf4;
        }



        .checkerboard-bg {
            background-image:
                linear-gradient(45deg, #e5e7eb 25%, transparent 25%),
                linear-gradient(-45deg, #e5e7eb 25%, transparent 25%),
                linear-gradient(45deg, transparent 75%, #e5e7eb 75%),
                linear-gradient(-45deg, transparent 75%, #e5e7eb 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
            background-color: white;
        }

        /* Loading Animation */
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #16a34a;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
            display: inline-block;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        /* Custom Scrollbar to ensure visibility */
        .custom-scrollbar::-webkit-scrollbar {
            width: 12px;
            height: 12px;
        }

        .custom-scrollbar::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 0 0 4px 0;
        }

        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #c1c1c1;
            border-radius: 6px;
            border: 3px solid #f1f1f1;
        }

        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: #a8a8a8;
        }

        .custom-scrollbar::-webkit-scrollbar-corner {
            background: #f1f1f1;
        }
    </style>
</head>

<body class="text-gray-800 min-h-screen flex flex-col">

    <header class="bg-green-600 text-white p-4 shadow-md">
        <div class="container mx-auto flex justify-between items-center">
            <h1 class="text-xl font-bold flex items-center gap-2">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
                    stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
                    style="width: 24px; height: 24px;">
                    <path
                        d="M12 2a10 10 0 1 0 10 10A10 10 0 0 0 12 2zm0 14a1 1 0 1 1 0-2 1 1 0 0 1 0 2zm0-4a1 1 0 0 1-1-1V7a1 1 0 0 1 2 0v4a1 1 0 0 1-1 1z" />
                </svg>
                LINEスタンプ分割＆背景透過
            </h1>
            <a href="https://creator.line.me/ja/guideline/sticker/" target="_blank"
                class="text-xs bg-white text-green-600 px-3 py-1 rounded-full hover:bg-green-100 transition">制作ガイドライン</a>
        </div>
    </header>

    <main class="container mx-auto p-4 flex-grow max-w-5xl">



        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">

            <div class="contents lg:block lg:col-span-1 lg:space-y-6">

                <!-- 1. 画像選択 -->
                <div class="bg-white p-6 rounded-lg shadow order-1">
                    <label class="block text-sm font-bold mb-2 text-gray-700">1. 画像を選択</label>
                    <div class="relative border-2 border-dashed border-gray-300 rounded-lg p-6 hover:bg-gray-50 transition text-center cursor-pointer"
                        id="dropZone">
                        <input type="file" id="imageInput" accept="image/png, image/jpeg"
                            class="absolute inset-0 w-full h-full opacity-0 cursor-pointer z-10">
                        <div class="space-y-2 pointer-events-none">
                            <svg class="mx-auto h-12 w-12 text-gray-400" stroke="currentColor" fill="none"
                                viewBox="0 0 48 48" style="width: 48px; height: 48px;">
                                <path
                                    d="M28 8H12a4 4 0 00-4 4v20m32-12v8m0 0v8a4 4 0 01-4 4H12a4 4 0 01-4-4v-4m32-4l-3.172-3.172a4 4 0 00-5.656 0L28 28M8 32l9.172-9.172a4 4 0 015.656 0L28 28m0 0l4 4m4-24h8m-4-4v8m-12 4h.02"
                                    stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
                            </svg>
                            <p class="text-sm text-gray-600">クリックまたはD&D</p>
                        </div>
                    </div>
                </div>

                <!-- 2. 分割設定 -->
                <div class="bg-white p-6 rounded-lg shadow order-3">
                    <div class="mb-4">
                        <label class="block text-sm font-bold text-gray-700">2. 分割設定</label>
                    </div>

                    <div class="grid grid-cols-2 gap-4 mb-4">
                        <div>
                            <label class="block text-xs text-gray-500 mb-1">横 (Cols)</label>
                            <input type="number" id="colInput" value="4" min="1" max="10"
                                class="w-full border border-gray-300 rounded px-3 py-2 outline-none">
                        </div>
                        <div>
                            <label class="block text-xs text-gray-500 mb-1">縦 (Rows)</label>
                            <input type="number" id="rowInput" value="4" min="1" max="10"
                                class="w-full border border-gray-300 rounded px-3 py-2 outline-none">
                        </div>
                    </div>

                    <div class="mb-4">
                        <label class="block text-xs text-gray-500 mb-1">メイン/タブ画像</label>
                        <select id="mainImageIndex" class="w-full border border-gray-300 rounded px-3 py-2 text-sm">
                            <option value="0">1番目 (左上)</option>
                        </select>
                    </div>
                </div>

                <!-- 3. 背景透過設定 -->
                <div class="bg-white p-6 rounded-lg shadow space-y-4 order-4">
                    <label class="block text-sm font-bold text-gray-700">3. 背景透過設定</label>

                    <!-- 色指定モード設定 -->
                    <div id="panelColor" class="space-y-3">
                        <div class="flex items-center gap-2">
                            <input type="checkbox" id="autoRemoveBg" checked
                                class="w-5 h-5 text-green-600 rounded focus:ring-green-500 cursor-pointer">
                            <label for="autoRemoveBg"
                                class="text-sm font-bold text-gray-800 cursor-pointer select-none">
                                背景を自動除去
                            </label>
                        </div>
                        <p class="text-xs text-gray-500 ml-7">
                            画像の四隅から繋がっている背景色を自動で消します。
                        </p>

                        <div class="ml-7 pt-2">
                            <label class="block text-xs text-gray-500 mb-1">色の許容範囲(あいまいさ): <span
                                    id="toleranceVal">20</span></label>
                            <input type="range" id="toleranceRange" min="5" max="70" value="20"
                                class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                        </div>

                        <div class="flex gap-2">
                            <button id="undoBtn" disabled
                                class="flex-1 text-xs flex items-center justify-center gap-1 bg-gray-100 px-3 py-1.5 rounded hover:bg-gray-200 disabled:opacity-50 transition">
                                <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24"
                                    fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                    stroke-linejoin="round">
                                    <path d="M3 7v6h6" />
                                    <path d="M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3L3 13" />
                                </svg>
                                元に戻す
                            </button>
                            <button id="reRemoveBtn" disabled
                                class="hidden flex-1 text-xs flex items-center justify-center gap-1 bg-green-500 text-white px-3 py-1.5 rounded hover:bg-green-600 disabled:opacity-50 transition">
                                <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24"
                                    fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                    stroke-linejoin="round">
                                    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" />
                                    <polyline points="7 10 12 15 17 10" />
                                    <line x1="12" y1="15" x2="12" y2="3" />
                                </svg>
                                背景を除去
                            </button>
                        </div>
                    </div>

                    <hr class="border-gray-100">

                    <div class="hidden flex items-start gap-2 pt-2">
                        <input type="checkbox" id="autoCenter" checked
                            class="mt-1 w-4 h-4 text-green-600 border-gray-300 rounded focus:ring-green-500 cursor-pointer">
                        <label for="autoCenter" class="text-sm text-gray-700 cursor-pointer select-none">
                            <span class="font-bold block">自動トリミング＆中央揃え</span>
                            <span class="text-xs text-gray-500 leading-tight">余白をカットして中央に配置します。</span>
                        </label>
                    </div>
                </div>

                <button id="generateBtn" disabled
                    class="w-full bg-green-600 text-white font-bold py-3 px-4 rounded shadow-lg hover:bg-green-700 disabled:bg-gray-400 disabled:cursor-not-allowed transition flex justify-center items-center gap-2 order-5">
                    <span id="btnText">変換＆ZIP作成</span>
                </button>
                <div id="statusContainer" class="hidden text-center order-6" style="display: none;">
                    <div class="loader mb-2"></div>
                    <div id="statusMsg" class="text-sm font-semibold text-green-700">処理中...</div>
                </div>

            </div>

            <div class="contents lg:block lg:col-span-2">
                <div class="bg-white p-4 rounded-lg shadow h-full flex flex-col order-2">
                    <h3 class="text-sm font-bold text-gray-700 mb-2 flex justify-between items-center">
                        <span class="lg:hidden">プレビュー画面(タップして編集)</span>
                        <span class="hidden lg:inline">プレビュー画面(クリックして編集)</span>
                    </h3>
                    <div class="flex-grow canvas-container relative border rounded bg-gray-50 overflow-hidden flex items-center justify-center min-h-[400px]"
                        id="previewContainer">
                        <p class="text-gray-400 text-sm pointer-events-none">画像がここに表示されます</p>
                        <!-- Canvas for editing -->
                        <canvas id="editorCanvas"
                            class="hidden max-w-full max-h-full object-contain z-10 cursor-crosshair checkerboard-bg"></canvas>
                        <div id="gridOverlay"
                            class="absolute top-0 left-0 pointer-events-none z-20 border-collapse border border-red-500 hidden">
                        </div>
                    </div>
                </div>
            </div>

        </div>

        <!-- Detail Editor -->
        <div id="detailEditor" class="hidden mt-1 lg:mt-6 bg-white p-1 lg:p-6 rounded-lg shadow">
            <div class="flex justify-between items-center mb-1 lg:mb-4">
                <button id="prevImageBtn" disabled
                    class="flex items-center gap-1 px-3 py-2 bg-white border border-gray-300 rounded hover:bg-gray-50 disabled:opacity-50 disabled:cursor-not-allowed transition text-sm">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none"
                        stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <polyline points="15 18 9 12 15 6"></polyline>
                    </svg>
                    前の画像
                </button>
                <h3 class="text-sm font-bold text-gray-700">詳細編集 - 画像 <span id="detailEditorIndex">1</span></h3>
                <button id="nextImageBtn" disabled
                    class="flex items-center gap-1 px-3 py-2 bg-green-600 text-white border border-green-600 rounded hover:bg-green-700 disabled:opacity-50 disabled:bg-gray-400 disabled:border-gray-400 disabled:cursor-not-allowed transition text-sm">
                    次の画像
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none"
                        stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <polyline points="9 18 15 12 9 6"></polyline>
                    </svg>
                </button>
            </div>

            <div class="grid grid-cols-1 lg:grid-cols-4 gap-2 lg:gap-6">
                <!-- Canvas Area -->
                <div class="lg:col-span-3">
                    <div class="canvas-container custom-scrollbar relative border rounded bg-gray-50 overflow-auto w-full h-[40vh] lg:h-[70vh] flex"
                        id="detailContainer">
                        <div id="zoomWrapper" class="relative m-auto">
                            <!-- Center Grid Overlay -->
                            <div id="centerGrid" class="absolute inset-0 pointer-events-none hidden z-20">
                                <div class="absolute top-1/2 left-0 w-full h-px bg-red-500/50"></div>
                                <div class="absolute left-1/2 top-0 h-full w-px bg-red-500/50"></div>
                            </div>
                            <canvas id="detailCanvas" class="absolute shadow-lg z-10 origin-top-left"
                                style="cursor: crosshair;"></canvas>
                            <div id="detailCanvasWrapper" class="absolute z-0 origin-top-left">
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Tool Panel -->
                <div class="lg:col-span-1 space-y-1 lg:space-y-3">
                    <!-- Navigation (Finish) -->
                    <div class="bg-gray-50 p-1 lg:p-3 rounded">
                        <button id="closeEditorBtn"
                            class="w-full px-6 py-2 text-sm bg-green-600 text-white rounded hover:bg-green-700 transition font-bold">
                            編集完了して戻る
                        </button>
                    </div>

                    <!-- Tools & History Group -->
                    <div class="bg-gray-50 p-2 lg:p-3 rounded">
                        <label class="block text-xs font-bold text-gray-700 mb-2">ツール & 履歴</label>

                        <!-- Tools Row -->
                        <div class="flex gap-2 mb-3">
                            <button id="toolMagicWand"
                                class="flex-1 flex flex-col items-center justify-center gap-1 p-2 rounded bg-white border-2 border-gray-300 hover:border-green-500 transition h-16">
                                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24"
                                    fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                    stroke-linejoin="round">
                                    <path d="M15 4V2"></path>
                                    <path d="M15 16v-2"></path>
                                    <path d="M8 9h2"></path>
                                    <path d="M20 9h2"></path>
                                    <path d="M17.8 11.8 19 13"></path>
                                    <path d="M15 9h0"></path>
                                    <path d="M17.8 6.2 19 5"></path>
                                    <path d="m3 21 9-9"></path>
                                    <path d="M12.2 6.2 11 5"></path>
                                </svg>
                                <span class="text-[10px] leading-none">自動透過</span>
                            </button>
                            <button id="toolBrush"
                                class="flex-1 flex flex-col items-center justify-center gap-1 p-2 rounded bg-white border-2 border-green-500 hover:border-green-500 transition h-16">
                                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24"
                                    fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                    stroke-linejoin="round">
                                    <path d="m9.06 11.9 8.07-8.06a2.85 2.85 0 1 1 4.03 4.03l-8.06 8.08"></path>
                                    <path
                                        d="M7.07 14.94c-1.66 0-3 1.35-3 3.02 0 1.33-2.5 1.52-2 2.02 1.08 1.1 2.49 2.02 4 2.02 2.2 0 4-1.8 4-4.04a3.01 3.01 0 0 0-3-3.02z">
                                    </path>
                                </svg>
                                <span class="text-[10px] leading-none">ブラシ</span>
                            </button>
                            <button id="toolMove"
                                class="flex-1 flex flex-col items-center justify-center gap-1 p-2 rounded bg-white border-2 border-gray-300 hover:border-green-500 transition h-16">
                                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24"
                                    fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                    stroke-linejoin="round">
                                    <polyline points="5 9 2 12 5 15"></polyline>
                                    <polyline points="9 5 12 2 15 5"></polyline>
                                    <polyline points="15 19 12 22 9 19"></polyline>
                                    <polyline points="19 9 22 12 19 15"></polyline>
                                    <line x1="2" y1="12" x2="22" y2="12"></line>
                                    <line x1="12" y1="2" x2="12" y2="22"></line>
                                </svg>
                                <span class="text-[10px] leading-none">配置</span>
                            </button>
                        </div>

                        <!-- History Row -->
                        <div class="flex gap-2">
                            <button id="detailUndoBtn" disabled
                                class="flex-1 flex items-center justify-center gap-1 px-2 py-2 text-xs bg-white border border-gray-300 rounded hover:bg-gray-50 disabled:opacity-50 transition">
                                <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24"
                                    fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                    stroke-linejoin="round">
                                    <path d="M3 7v6h6" />
                                    <path d="M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3L3 13" />
                                </svg>
                                戻る
                            </button>
                            <button id="detailRedoBtn" disabled
                                class="flex-1 flex items-center justify-center gap-1 px-2 py-2 text-xs bg-white border border-gray-300 rounded hover:bg-gray-50 disabled:opacity-50 transition">
                                <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24"
                                    fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                    stroke-linejoin="round">
                                    <path d="M21 7v6h-6" />
                                    <path d="M3 17a9 9 0 0 1 9-9 9 9 0 0 1 6 2.3L21 13" />
                                </svg>
                                進む
                            </button>
                            <button id="detailResetBtn"
                                class="flex-1 px-2 py-2 text-xs bg-red-100 text-red-600 border border-red-200 rounded hover:bg-red-200 transition">
                                リセット
                            </button>
                        </div>
                    </div>

                    <!-- Brush Settings (only visible when brush tool is selected) -->
                    <div id="brushSizePanel" class="bg-gray-50 p-2 lg:p-3 rounded">
                        <div class="flex justify-between items-center mb-2">
                            <label class="text-xs font-bold text-gray-700">ブラシ設定</label>
                            <span class="text-xs text-gray-500"><span id="brushSizeVal">15</span>px</span>
                        </div>
                        <input type="range" id="brushSizeSlider" min="1" max="50" value="15"
                            class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer mb-3">

                        <div id="brushModePanel" class="flex gap-4">
                            <label class="flex items-center gap-2 cursor-pointer">
                                <input type="radio" name="brushMode" value="erase" checked
                                    class="w-4 h-4 text-green-600">
                                <span class="text-xs font-bold">透過 (消す)</span>
                            </label>
                            <label class="flex items-center gap-2 cursor-pointer">
                                <input type="radio" name="brushMode" value="restore" class="w-4 h-4 text-green-600">
                                <span class="text-xs font-bold">復元 (戻す)</span>
                            </label>
                        </div>
                    </div>

                    <!-- Position Controls (only visible when move tool is selected) -->
                    <div id="positionPanel" class="bg-gray-50 p-2 lg:p-3 rounded hidden">
                        <div class="flex justify-between items-center mb-2">
                            <label class="text-xs font-bold text-gray-700">位置調整</label>
                            <div class="text-xs text-gray-600">X:<span id="posX">0</span> Y:<span id="posY">0</span>
                            </div>
                        </div>
                        <button id="centerBtn"
                            class="w-full px-3 py-2 text-xs bg-blue-500 text-white rounded hover:bg-blue-600 transition mb-2">中央に配置</button>
                        <div class="text-[10px] text-gray-500 text-center">矢印キー: 1px / Shift+矢印: 10px</div>
                    </div>

                    <!-- View Settings Group -->
                    <div class="bg-gray-50 p-3 rounded">
                        <label class="block text-xs font-bold text-gray-700 mb-2">表示設定</label>

                        <!-- Zoom -->
                        <div class="mb-3">
                            <div class="flex items-center gap-2 mb-1">
                                <span class="text-[10px] text-gray-500 w-8">ズーム</span>
                                <input type="range" id="zoomSlider" min="100" max="500" value="100" step="10"
                                    class="flex-1 h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                                <span id="zoomValue" class="text-[10px] font-bold w-8 text-right">100%</span>
                            </div>
                            <div class="flex justify-end gap-1">
                                <button
                                    class="zoom-btn px-2 py-0.5 text-[10px] bg-white border border-green-500 rounded"
                                    data-zoom="1">100%</button>
                                <button class="zoom-btn px-2 py-0.5 text-[10px] bg-white border border-gray-300 rounded"
                                    data-zoom="2">200%</button>
                                <button class="zoom-btn px-2 py-0.5 text-[10px] bg-white border border-gray-300 rounded"
                                    data-zoom="4">400%</button>
                            </div>
                        </div>

                        <!-- Background -->
                        <div class="flex items-center gap-2 mb-3">
                            <span class="text-[10px] text-gray-500 w-8">背景</span>
                            <div class="flex-1 grid grid-cols-3 gap-1">
                                <button
                                    class="bg-pattern-btn px-1 py-1 text-[10px] bg-white border border-green-500 rounded"
                                    data-pattern="dark">黒</button>
                                <button
                                    class="bg-pattern-btn px-1 py-1 text-[10px] bg-white border border-gray-300 rounded"
                                    data-pattern="transparent">透過</button>
                                <button
                                    class="bg-pattern-btn px-1 py-1 text-[10px] bg-white border border-gray-300 rounded"
                                    data-pattern="normal">LINE</button>
                            </div>
                        </div>

                        <!-- Preview Button -->
                        <button id="showDetailPreviewBtn"
                            class="w-full px-3 py-2 text-xs bg-white border border-green-500 text-green-600 rounded hover:bg-green-50 transition flex items-center justify-center gap-2">
                            <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24"
                                fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                stroke-linejoin="round">
                                <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z" />
                                <circle cx="12" cy="12" r="3" />
                            </svg>
                            完成イメージを確認
                        </button>
                    </div>
                </div>
            </div>
        </div>
        </div>

        <!-- LINE Chat Preview -->
        <div id="linePreview" class="hidden mt-6 bg-white p-6 rounded-lg shadow">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-lg font-bold text-gray-700">完成イメージ</h3>
                <!-- Background Switcher -->
                <div class="flex gap-2">
                    <button
                        class="preview-bg-btn px-4 py-2 text-sm bg-white border-2 border-gray-300 rounded hover:bg-gray-50 transition"
                        data-bg="light">Light</button>
                    <button
                        class="preview-bg-btn px-4 py-2 text-sm bg-white border-2 border-gray-300 rounded hover:bg-gray-50 transition"
                        data-bg="normal">Normal</button>
                    <button
                        class="preview-bg-btn px-4 py-2 text-sm bg-white border-2 border-green-500 rounded hover:bg-gray-50 transition"
                        data-bg="dark">Dark</button>
                </div>
            </div>

            <!-- Chat Container -->
            <div id="chatContainer" class="relative rounded-lg overflow-hidden border-2 border-gray-300"
                style="min-height: 500px; background: #1a1a1a;">
                <!-- Header -->
                <div class="bg-white border-b border-gray-200 p-3 flex items-center gap-3">
                    <button class="text-gray-600">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
                            stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M15 18l-6-6 6-6" />
                        </svg>
                    </button>
                    <div class="flex-1 text-center">
                        <div class="font-bold text-gray-800">完成イメージ</div>
                    </div>
                    <button class="text-gray-600">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
                            stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <circle cx="12" cy="12" r="1" />
                            <circle cx="12" cy="5" r="1" />
                            <circle cx="12" cy="19" r="1" />
                        </svg>
                    </button>
                </div>

                <!-- Chat Messages -->
                <div id="chatMessages" class="p-4 space-y-3" style="min-height: 400px;">
                    <!-- Messages will be inserted here by JavaScript -->
                </div>
            </div>
        </div>

    </main>

    <!-- Detail Editor Preview Modal -->
    <div id="detailPreviewModal"
        class="hidden fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center p-4">
        <div class="bg-white rounded-lg p-6 max-w-2xl">
            <!-- Modal Header -->
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-xl font-bold text-gray-800">完成イメージプレビュー</h3>
                <button id="closeDetailPreviewBtn" class="text-gray-500 hover:text-gray-700 transition">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
                        stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <line x1="18" y1="6" x2="6" y2="18" />
                        <line x1="6" y1="6" x2="18" y2="18" />
                    </svg>
                </button>
            </div>

            <!-- Background Switcher -->
            <div class="flex justify-center gap-2 mb-4">
                <button
                    class="preview-switch-btn px-4 py-2 text-sm bg-white border-2 border-gray-300 rounded hover:bg-gray-50 transition"
                    data-bg="light">明るい</button>
                <button
                    class="preview-switch-btn px-4 py-2 text-sm bg-white border-2 border-green-500 rounded hover:bg-gray-50 transition"
                    data-bg="normal">標準</button>
                <button
                    class="preview-switch-btn px-4 py-2 text-sm bg-white border-2 border-gray-300 rounded hover:bg-gray-50 transition"
                    data-bg="dark">暗い</button>
            </div>

            <!-- Smartphone Mockup -->
            <div class="flex justify-center">
                <div class="relative" style="width: 375px;">
                    <!-- Phone Frame -->
                    <div class="bg-gray-900 rounded-[3rem] p-3 shadow-2xl">
                        <!-- Screen -->
                        <div class="bg-black rounded-[2.5rem] overflow-hidden relative" style="height: 667px;">
                            <!-- LINE Screen Content -->
                            <div class="h-full flex flex-col">
                                <!-- LINE Header -->
                                <div
                                    class="bg-white border-b border-gray-200 p-3 flex items-center gap-3 relative z-20">
                                    <button class="text-gray-600">
                                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"
                                            viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                                            stroke-linecap="round" stroke-linejoin="round">
                                            <path d="M15 18l-6-6 6-6" />
                                        </svg>
                                    </button>
                                    <div class="flex-1 text-center">
                                        <div class="font-bold text-gray-800">完成イメージ</div>
                                    </div>
                                    <button class="text-gray-600">
                                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"
                                            viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                                            stroke-linecap="round" stroke-linejoin="round">
                                            <circle cx="12" cy="12" r="1" />
                                            <circle cx="12" cy="5" r="1" />
                                            <circle cx="12" cy="19" r="1" />
                                        </svg>
                                    </button>
                                </div>

                                <!-- Chat Messages (Scrollable) -->
                                <div id="previewChatMobile" class="flex-1 p-4 space-y-3 overflow-y-auto"
                                    style="background: #8fb4d8;">
                                    <!-- Content will be inserted by JavaScript -->
                                </div>

                                <!-- Chat Input -->
                                <div class="bg-white border-t border-gray-200 p-3">
                                    <div class="flex items-center gap-2">
                                        <button class="text-gray-500">
                                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"
                                                viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                                                stroke-linecap="round" stroke-linejoin="round">
                                                <circle cx="12" cy="12" r="10" />
                                                <line x1="12" y1="8" x2="12" y2="12" />
                                                <line x1="12" y1="16" x2="12.01" y2="16" />
                                            </svg>
                                        </button>
                                        <div class="flex-1 bg-gray-100 rounded-full px-4 py-2">
                                            <input type="text" placeholder="メッセージ"
                                                class="w-full bg-transparent text-sm outline-none" disabled>
                                        </div>
                                        <button class="text-gray-500">
                                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"
                                                viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                                                stroke-linecap="round" stroke-linejoin="round">
                                                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" />
                                                <polyline points="17 8 12 3 7 8" />
                                                <line x1="12" y1="3" x2="12" y2="15" />
                                            </svg>
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // DOM Elements
        const imageInput = document.getElementById('imageInput');
        const dropZone = document.getElementById('dropZone');
        const gridOverlay = document.getElementById('gridOverlay');
        const colInput = document.getElementById('colInput');
        const rowInput = document.getElementById('rowInput');
        const generateBtn = document.getElementById('generateBtn');
        const btnText = document.getElementById('btnText');
        const statusMsg = document.getElementById('statusMsg');
        const statusContainer = document.getElementById('statusContainer');
        const mainImageIndex = document.getElementById('mainImageIndex');
        const previewContainer = document.getElementById('previewContainer');
        const autoCenterCheckbox = document.getElementById('autoCenter');

        // Elements for Color Removal
        const editorCanvas = document.getElementById('editorCanvas');
        const autoRemoveBgCheckbox = document.getElementById('autoRemoveBg');
        const toleranceRange = document.getElementById('toleranceRange');
        const toleranceVal = document.getElementById('toleranceVal');
        const undoBtn = document.getElementById('undoBtn');

        // Detail Editor Elements
        const detailEditor = document.getElementById('detailEditor');
        const detailCanvas = document.getElementById('detailCanvas');
        const detailEditorIndex = document.getElementById('detailEditorIndex');
        const toolMoveBtn = document.getElementById('toolMove');
        const toolBrushBtn = document.getElementById('toolBrush');
        const toolMagicWandBtn = document.getElementById('toolMagicWand');
        const brushSizePanel = document.getElementById('brushSizePanel');
        const brushModePanel = document.getElementById('brushModePanel');
        const brushSizeSlider = document.getElementById('brushSizeSlider');
        const brushSizeVal = document.getElementById('brushSizeVal');
        const positionPanel = document.getElementById('positionPanel');
        const posXDisplay = document.getElementById('posX');
        const posYDisplay = document.getElementById('posY');
        const centerBtn = document.getElementById('centerBtn');
        const detailUndoBtn = document.getElementById('detailUndoBtn');
        const detailRedoBtn = document.getElementById('detailRedoBtn');
        const detailResetBtn = document.getElementById('detailResetBtn');
        const prevImageBtn = document.getElementById('prevImageBtn');
        const nextImageBtn = document.getElementById('nextImageBtn');
        const closeEditorBtn = document.getElementById('closeEditorBtn');
        const zoomBtns = document.querySelectorAll('.zoom-btn');
        const centerGrid = document.getElementById('centerGrid');

        let originalImage = null;
        let history = []; // Undo history
        let ctx = null; // Editor canvas context
        let cellCheckStates = []; // Checkbox states for each grid cell

        // Detail Editor State
        let detailCtx = null;
        let currentEditingIndex = -1;
        let currentTool = 'magicWand'; // 'move', 'brush', 'magicWand'
        let brushSize = 15;
        let brushMode = 'erase'; // 'erase' or 'restore'
        let currentZoom = 1;
        let isPanning = false;
        let panStart = { x: 0, y: 0 };
        let isDragging = false;
        let dragStart = { x: 0, y: 0 };
        let dragStartImageData = null; // For move tool baking
        let currentBgPattern = 'dark'; // Background pattern for detail editor (default: dark)

        // Cell editor states: stores edited image data and position for each cell
        let cellEditorStates = {};

        // Constants
        const SPECS = {
            sticker: { w: 370, h: 320, margin: 10 },
            main: { w: 240, h: 240 },
            tab: { w: 96, h: 74 }
        };

        // Event Listeners
        if (imageInput) imageInput.addEventListener('change', handleFileSelect);
        if (colInput) colInput.addEventListener('input', updateGrid);
        if (rowInput) rowInput.addEventListener('input', updateGrid);
        if (generateBtn) generateBtn.addEventListener('click', generateZip);



        // Color Removal Controls
        toleranceRange.addEventListener('input', (e) => {
            toleranceVal.innerText = e.target.value;

            // If background was removed and slider changed, show both buttons
            if (backgroundRemoved) {
                toleranceChanged = true;
                updateButtons();
            }
        });
        autoRemoveBgCheckbox.addEventListener('change', applyAutoRemoval);
        undoBtn.addEventListener('click', undo);

        // Re-remove button listener
        const reRemoveBtn = document.getElementById('reRemoveBtn');
        if (reRemoveBtn) {
            reRemoveBtn.addEventListener('click', () => {
                applyAutoRemoval();
            });
        }

        // Canvas Interaction
        editorCanvas.addEventListener('click', handleCanvasClick);

        const resizeObserver = new ResizeObserver(() => updateGridUI());
        if (previewContainer) resizeObserver.observe(previewContainer);

        // Drag and Drop
        if (dropZone) {
            dropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropZone.classList.add('bg-green-50', 'border-green-400');
            });
            dropZone.addEventListener('dragleave', () => {
                dropZone.classList.remove('bg-green-50', 'border-green-400');
            });
            dropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                dropZone.classList.remove('bg-green-50', 'border-green-400');
                if (e.dataTransfer.files.length > 0) {
                    imageInput.files = e.dataTransfer.files;
                    handleFileSelect({ target: imageInput });
                }
            });
        }



        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function (e) {
                originalImage = new Image();
                originalImage.onload = function () {
                    // Setup Canvas
                    editorCanvas.width = originalImage.width;
                    editorCanvas.height = originalImage.height;
                    ctx = editorCanvas.getContext('2d', { willReadFrequently: true });

                    resetCanvas();

                    editorCanvas.classList.remove('hidden');
                    previewContainer.querySelector('p')?.remove();

                    // Clear all cell editor states when new image is uploaded
                    cellEditorStates = {};
                    currentEditingIndex = -1;
                    if (detailEditor && !detailEditor.classList.contains('hidden')) {
                        closeDetailEditor();
                    }

                    // Initial Auto Removal
                    if (autoRemoveBgCheckbox.checked) {
                        applyAutoRemoval();
                    }

                    updateGrid();
                    updateSelectOptions();
                    generateBtn.disabled = false;
                }
                originalImage.src = e.target.result;
            }
            reader.readAsDataURL(file);
        }

        function resetCanvas() {
            if (!ctx || !originalImage) return;
            ctx.clearRect(0, 0, editorCanvas.width, editorCanvas.height);
            ctx.drawImage(originalImage, 0, 0);
            saveState();
            history = [ctx.getImageData(0, 0, editorCanvas.width, editorCanvas.height)]; // Reset history
            backgroundRemoved = false;
            toleranceChanged = false;
            updateButtons();
        }

        function saveState() {
            if (!ctx) return;
            if (history.length > 10) history.shift(); // Limit history
            history.push(ctx.getImageData(0, 0, editorCanvas.width, editorCanvas.height));
            updateButtons(); // Call updateButtons instead of updateUndoBtn
        }

        let backgroundRemoved = false; // Track if background was removed
        let toleranceChanged = false;  // Track if slider was adjusted after removal

        function undo() {
            if (history.length <= 1) return;
            history.pop(); // Remove current state
            const prevState = history[history.length - 1];
            ctx.putImageData(prevState, 0, 0);

            backgroundRemoved = false;
            toleranceChanged = false;
            updateButtons();
        }

        function updateButtons() {
            // Assuming reRemoveBtn is defined globally or passed

            if (toleranceChanged && backgroundRemoved) {
                // Show both buttons
                undoBtn.classList.remove('hidden');
                reRemoveBtn.classList.remove('hidden');
                undoBtn.disabled = false;
                reRemoveBtn.disabled = false;
            } else if (backgroundRemoved) {
                // Show only undo button
                undoBtn.classList.remove('hidden');
                reRemoveBtn.classList.add('hidden');
                undoBtn.disabled = false;
            } else {
                // Initial state - only undo button, disabled
                undoBtn.classList.remove('hidden');
                reRemoveBtn.classList.add('hidden');
                undoBtn.disabled = history.length <= 1;
            }
        }

        function applyAutoRemoval() {
            if (!ctx) return;

            // If checkbox is not checked, just reset
            if (!autoRemoveBgCheckbox.checked) {
                resetCanvas();
                return;
            }
            // Reset first
            ctx.drawImage(originalImage, 0, 0);

            // Remove corners
            const corners = [
                { x: 0, y: 0 },
                { x: editorCanvas.width - 1, y: 0 },
                { x: 0, y: editorCanvas.height - 1 },
                { x: editorCanvas.width - 1, y: editorCanvas.height - 1 }
            ];

            const tolerance = parseInt(toleranceRange.value);

            // Process corners
            corners.forEach(p => {
                floodFill(p.x, p.y, tolerance);
            });
            saveState();

            backgroundRemoved = true;
            toleranceChanged = false;
            updateButtons();
        }

        function handleCanvasClick(e) {
            if (currentMode !== 'color' || !ctx) return;

            const rect = editorCanvas.getBoundingClientRect();
            const scaleX = editorCanvas.width / rect.width;
            const scaleY = editorCanvas.height / rect.height;

            const x = Math.floor((e.clientX - rect.left) * scaleX);
            const y = Math.floor((e.clientY - rect.top) * scaleY);

            const tolerance = parseInt(toleranceRange.value);
            floodFill(x, y, tolerance);
            saveState();
        }

        // Flood Fill Algorithm (Queue-based)
        function floodFill(startX, startY, tolerance, targetCtx = ctx, width = editorCanvas.width, height = editorCanvas.height) {
            const imageData = targetCtx.getImageData(0, 0, width, height);
            const data = imageData.data;

            const startPos = (startY * width + startX) * 4;
            const startR = data[startPos];
            const startG = data[startPos + 1];
            const startB = data[startPos + 2];
            const startA = data[startPos + 3];

            if (startA === 0) return; // Already transparent

            const queue = [[startX, startY]];
            const visited = new Uint8Array(width * height); // Track visited pixels

            while (queue.length > 0) {
                const [x, y] = queue.pop();
                const pos = (y * width + x) * 4;

                if (visited[y * width + x]) continue;

                // Check color match
                const r = data[pos];
                const g = data[pos + 1];
                const b = data[pos + 2];
                const a = data[pos + 3];

                if (a === 0) continue; // Skip if already transparent

                const diff = Math.abs(r - startR) + Math.abs(g - startG) + Math.abs(b - startB);

                // Tolerance check (simple sum of diffs < tolerance * 3)
                if (diff <= tolerance * 3) {
                    // Make transparent
                    data[pos + 3] = 0;
                    visited[y * width + x] = 1;

                    // Add neighbors
                    if (x > 0) queue.push([x - 1, y]);
                    if (x < width - 1) queue.push([x + 1, y]);
                    if (y > 0) queue.push([x, y - 1]);
                    if (y < height - 1) queue.push([x, y + 1]);
                }
            }

            if (targetCtx === ctx) {
                ctx.putImageData(imageData, 0, 0);
            } else {
                targetCtx.putImageData(imageData, 0, 0);
            }
        }

        function updateGrid() {
            if (!originalImage) return;
            updateGridUI();
            updateSelectOptions();
        }

        function updateGridUI() {
            if (!editorCanvas.width || editorCanvas.classList.contains('hidden')) return;

            const cols = parseInt(colInput.value) || 1;
            const rows = parseInt(rowInput.value) || 1;

            // Match overlay to canvas display size
            const rect = editorCanvas.getBoundingClientRect();
            // Need to account for object-contain centering if parent is larger
            // But here editorCanvas is max-w-full, so rect should be accurate to the visible image

            // However, if the canvas is smaller than container, it might be centered.
            // We need to position the gridOverlay exactly over the canvas element.

            gridOverlay.style.width = `${editorCanvas.offsetWidth}px`;
            gridOverlay.style.height = `${editorCanvas.offsetHeight}px`;
            gridOverlay.style.top = `${editorCanvas.offsetTop}px`;
            gridOverlay.style.left = `${editorCanvas.offsetLeft}px`;

            gridOverlay.classList.remove('hidden');
            gridOverlay.innerHTML = '';
            gridOverlay.style.display = 'grid';
            gridOverlay.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
            gridOverlay.style.gridTemplateRows = `repeat(${rows}, 1fr)`;

            const total = cols * rows;

            // Initialize checkbox states if needed
            if (cellCheckStates.length !== total) {
                cellCheckStates = new Array(total).fill(true);
            }

            for (let i = 0; i < total; i++) {
                const cell = document.createElement('div');
                cell.className = 'group border border-red-500/50 flex flex-col items-start justify-between p-2 text-red-600 font-bold text-xs bg-red-100/10 hover:bg-red-100/30 transition relative overflow-hidden';
                cell.style.cursor = 'pointer';
                cell.style.pointerEvents = 'auto'; // Ensure it captures clicks

                // Single click: Open Detail Editor
                cell.addEventListener('click', (e) => {
                    openDetailEditor(i);
                });

                // Number label (Top-Left)
                const label = document.createElement('span');
                label.innerText = i + 1;
                label.className = 'absolute top-0 left-0 bg-white/80 px-2 py-1 text-xs font-bold rounded-br pointer-events-none z-10';
                cell.appendChild(label);

                // Hover Overlay
                const overlay = document.createElement('div');
                overlay.className = 'absolute inset-0 bg-black/40 flex items-center justify-center opacity-0 group-hover:opacity-100 transition duration-200 pointer-events-none';
                overlay.innerHTML = `
                    <div class="bg-white/90 text-gray-800 px-3 py-2 rounded-full shadow-lg flex items-center gap-2 transform scale-90 group-hover:scale-100 transition">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                            <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
                        </svg>
                        <span class="font-bold text-sm">編集する</span>
                    </div>
                `;
                cell.appendChild(overlay);

                gridOverlay.appendChild(cell);
            }
        }

        function toggleCellCheck(index) {
            cellCheckStates[index] = !cellCheckStates[index];
            updateGridUI(); // Refresh UI
            updateSelectOptions(); // Update main image select options
        }

        function updateSelectOptions() {
            const cols = parseInt(colInput.value) || 1;
            const rows = parseInt(rowInput.value) || 1;
            const total = cols * rows;
            const currentSelection = mainImageIndex.value;
            mainImageIndex.innerHTML = '';

            for (let i = 0; i < total; i++) {
                // Only add checked cells
                if (cellCheckStates[i]) {
                    const option = document.createElement('option');
                    option.value = i;
                    option.text = `${i + 1}番目の画像`;
                    mainImageIndex.appendChild(option);
                }
            }

            // Try to maintain current selection if still checked
            if (currentSelection < total && cellCheckStates[currentSelection]) {
                mainImageIndex.value = currentSelection;
            }
        }

        // --- Logic ---

        function getContentBoundingBox(ctx, width, height, threshold = 20) {
            const imgData = ctx.getImageData(0, 0, width, height);
            const data = imgData.data;
            let minX = width, minY = height, maxX = 0, maxY = 0, found = false;

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const i = (y * width + x) * 4;
                    if (data[i + 3] > threshold) { // Use custom threshold
                        if (x < minX) minX = x;
                        if (x > maxX) maxX = x;
                        if (y < minY) minY = y;
                        if (y > maxY) maxY = y;
                        found = true;
                    }
                }
            }
            return found ? { x: minX, y: minY, w: maxX - minX + 1, h: maxY - minY + 1 } : null;
        }

        async function generateZip() {
            if (!originalImage) return;

            // UI State Update
            generateBtn.disabled = true;
            generateBtn.classList.add('hidden');
            statusContainer.classList.remove('hidden');
            statusContainer.style.display = 'block';
            statusMsg.innerText = "処理を開始します...";
            statusMsg.className = "text-sm font-semibold text-green-700";

            try {
                let processImage;

                // Use the edited canvas as source
                processImage = new Image();
                processImage.src = editorCanvas.toDataURL();
                await new Promise(r => processImage.onload = r);

                statusMsg.innerText = "スタンプ画像を分割・生成中...";
                await new Promise(r => setTimeout(r, 100));

                const zip = new JSZip();
                const cols = parseInt(colInput.value);
                const rows = parseInt(rowInput.value);
                const totalCells = cols * rows;
                const cellW = processImage.naturalWidth / cols;
                const cellH = processImage.naturalHeight / rows;
                const selectedMainIndex = parseInt(mainImageIndex.value);
                const shouldAutoCenter = autoCenterCheckbox.checked;

                let outputIndex = 1; // Counter for output file names
                const stickerDataURLs = []; // Store sticker images for preview

                for (let i = 0; i < totalCells; i++) {
                    // Always process all cells
                    // if (!cellCheckStates[i]) continue;

                    let rawCanvas;
                    let srcX = 0, srcY = 0, srcW, srcH;

                    // Check if cell was edited in detail editor
                    if (cellEditorStates[i]) {
                        // Use edited image from detail editor
                        rawCanvas = document.createElement('canvas');
                        rawCanvas.width = SPECS.sticker.w;
                        rawCanvas.height = SPECS.sticker.h;
                        const rawCtx = rawCanvas.getContext('2d');
                        rawCtx.putImageData(cellEditorStates[i].imageData, 0, 0);

                        // Apply position offset
                        const posX = cellEditorStates[i].position.x;
                        const posY = cellEditorStates[i].position.y;

                        if (posX !== 0 || posY !== 0) {
                            // Create temp canvas with position offset
                            const tempCanvas = document.createElement('canvas');
                            tempCanvas.width = SPECS.sticker.w;
                            tempCanvas.height = SPECS.sticker.h;
                            const tempCtx = tempCanvas.getContext('2d');
                            tempCtx.drawImage(rawCanvas, posX, posY);
                            rawCanvas = tempCanvas;
                        }

                        srcW = SPECS.sticker.w;
                        srcH = SPECS.sticker.h;
                    } else {
                        // Original logic: extract from main canvas
                        const c = i % cols;
                        const r = Math.floor(i / cols);

                        rawCanvas = document.createElement('canvas');
                        rawCanvas.width = cellW;
                        rawCanvas.height = cellH;
                        const rawCtx = rawCanvas.getContext('2d');
                        rawCtx.drawImage(processImage, c * cellW, r * cellH, cellW, cellH, 0, 0, cellW, cellH);

                        srcW = cellW;
                        srcH = cellH;
                    }

                    // Determine Trim (only if auto-center is enabled and not from detail editor)
                    if (shouldAutoCenter && !cellEditorStates[i]) {
                        const rawCtx = rawCanvas.getContext('2d');
                        const bbox = getContentBoundingBox(rawCtx, srcW, srcH);
                        if (bbox) {
                            srcX = bbox.x; srcY = bbox.y; srcW = bbox.w; srcH = bbox.h;
                        }
                    }

                    // Draw Final
                    const drawCentered = (targetCanvas, tW, tH, margin) => {
                        const tCtx = targetCanvas.getContext('2d');
                        const maxW = tW - (margin * 2);
                        const maxH = tH - (margin * 2);
                        const scale = Math.min(maxW / srcW, maxH / srcH);
                        const drawW = srcW * scale;
                        const drawH = srcH * scale;
                        tCtx.drawImage(rawCanvas, srcX, srcY, srcW, srcH, (tW - drawW) / 2, (tH - drawH) / 2, drawW, drawH);
                    };

                    // Sticker
                    const stickerCanvas = document.createElement('canvas');
                    stickerCanvas.width = SPECS.sticker.w;
                    stickerCanvas.height = SPECS.sticker.h;

                    // If from detail editor, draw directly without centering
                    if (cellEditorStates[i]) {
                        const stickerCtx = stickerCanvas.getContext('2d');
                        stickerCtx.drawImage(rawCanvas, 0, 0);
                    } else {
                        drawCentered(stickerCanvas, SPECS.sticker.w, SPECS.sticker.h, SPECS.sticker.margin);
                    }

                    const fileName = `${outputIndex.toString().padStart(2, '0')}.png`;
                    zip.file(fileName, await new Promise(r => stickerCanvas.toBlob(r)));

                    // Store sticker for preview
                    stickerDataURLs.push(stickerCanvas.toDataURL());

                    // Main/Tab
                    if (i === selectedMainIndex) {
                        const mainCanvas = document.createElement('canvas');
                        mainCanvas.width = SPECS.main.w;
                        mainCanvas.height = SPECS.main.h;
                        drawCentered(mainCanvas, SPECS.main.w, SPECS.main.h, 0);
                        zip.file("main.png", await new Promise(r => mainCanvas.toBlob(r)));

                        const tabCanvas = document.createElement('canvas');
                        tabCanvas.width = SPECS.tab.w;
                        tabCanvas.height = SPECS.tab.h;
                        drawCentered(tabCanvas, SPECS.tab.w, SPECS.tab.h, 0);
                        zip.file("tab.png", await new Promise(r => tabCanvas.toBlob(r)));
                    }

                    outputIndex++; // Increment for next checked image
                }

                const content = await zip.generateAsync({ type: "blob" });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(content);
                link.download = "line_stickers.zip";
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);

                statusMsg.innerText = "完了しました！";

                // Show LINE Preview with stickers
                // showLinePreview(stickerDataURLs);

                setTimeout(() => {
                    statusContainer.classList.add('hidden');
                    statusContainer.style.display = 'none';
                    generateBtn.classList.remove('hidden');
                    generateBtn.disabled = false;
                }, 2000);

            } catch (err) {
                console.error(err);
                statusMsg.innerText = "エラー: " + err.message;
                statusMsg.className = "text-sm font-bold text-red-600";
                generateBtn.classList.remove('hidden');
            }
        }

        // ===== DETAIL EDITOR FUNCTIONS =====

        function openDetailEditor(index) {
            currentEditingIndex = index;
            detailEditorIndex.innerText = index + 1;

            // Initialize cell state if not exists
            if (!cellEditorStates[index]) {
                const cols = parseInt(colInput.value);
                const rows = parseInt(rowInput.value);
                const c = index % cols;
                const r = Math.floor(index / cols);
                const cellW = editorCanvas.width / cols;
                const cellH = editorCanvas.height / rows;

                // Extract from ORIGINAL image (before transparency)
                const originalCanvas = document.createElement('canvas');
                originalCanvas.width = SPECS.sticker.w;
                originalCanvas.height = SPECS.sticker.h;
                const originalCtx = originalCanvas.getContext('2d', { willReadFrequently: true });
                originalCtx.drawImage(originalImage, c * cellW, r * cellH, cellW, cellH, 0, 0, SPECS.sticker.w, SPECS.sticker.h);

                // Extract from edited canvas (after transparency)
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = SPECS.sticker.w;
                tempCanvas.height = SPECS.sticker.h;
                const tempCtx = tempCanvas.getContext('2d', { willReadFrequently: true });
                tempCtx.drawImage(editorCanvas, c * cellW, r * cellH, cellW, cellH, 0, 0, SPECS.sticker.w, SPECS.sticker.h);

                // Calculate auto-center position
                // Use stricter threshold (128) to ignore faint noise/shadows for centering
                const bbox = getContentBoundingBox(tempCtx, SPECS.sticker.w, SPECS.sticker.h, 128);

                let finalImageData;

                if (bbox) {
                    // Create a new canvas for the centered image
                    const centeredCanvas = document.createElement('canvas');
                    centeredCanvas.width = SPECS.sticker.w;
                    centeredCanvas.height = SPECS.sticker.h;
                    const centeredCtx = centeredCanvas.getContext('2d');

                    // Draw the trimmed content at the center of the new canvas
                    const targetX = Math.round((SPECS.sticker.w - bbox.w) / 2);
                    const targetY = Math.round((SPECS.sticker.h - bbox.h) / 2);

                    centeredCtx.drawImage(
                        tempCanvas,
                        bbox.x, bbox.y, bbox.w, bbox.h, // Source: trimmed area
                        targetX, targetY, bbox.w, bbox.h // Destination: center
                    );

                    finalImageData = centeredCtx.getImageData(0, 0, SPECS.sticker.w, SPECS.sticker.h);
                } else {
                    // Fallback if empty
                    finalImageData = tempCtx.getImageData(0, 0, SPECS.sticker.w, SPECS.sticker.h);
                }

                cellEditorStates[index] = {
                    imageData: finalImageData,
                    originalImageData: originalCtx.getImageData(0, 0, SPECS.sticker.w, SPECS.sticker.h),
                    position: { x: 0, y: 0 }, // Position is now 0,0 because image is centered
                    history: [],
                    historyIndex: -1
                };
            }

            // Setup detail canvas
            detailCanvas.width = SPECS.sticker.w;
            detailCanvas.height = SPECS.sticker.h;

            // Sync wrapper size
            const wrapper = document.getElementById('detailCanvasWrapper');
            if (wrapper) {
                wrapper.style.width = detailCanvas.width + 'px';
                wrapper.style.height = detailCanvas.height + 'px';
            }

            // Initialize zoom wrapper size
            const zoomWrapper = document.getElementById('zoomWrapper');
            if (zoomWrapper) {
                zoomWrapper.style.width = detailCanvas.width + 'px';
                zoomWrapper.style.height = detailCanvas.height + 'px';
            }

            detailCtx = detailCanvas.getContext('2d', { willReadFrequently: true });
            detailCtx.putImageData(cellEditorStates[index].imageData, 0, 0);

            // Save initial state to history
            if (cellEditorStates[index].history.length === 0) {
                saveDetailHistory();
            }

            // Show editor
            detailEditor.classList.remove('hidden');
            detailEditor.scrollIntoView({ behavior: 'smooth', block: 'start' });

            // Auto-fit Logic
            const container = detailEditor.querySelector('.canvas-container');
            const containerW = container.clientWidth;
            const containerH = container.clientHeight;

            // Calculate scale to fit with some padding
            const padding = 40;
            const scaleX = (containerW - padding) / SPECS.sticker.w;
            const scaleY = (containerH - padding) / SPECS.sticker.h;
            const fitScale = Math.min(scaleX, scaleY, 4); // Max zoom 4x initially

            // Apply fit scale
            setZoom(fitScale); // This sets currentZoom and transform

            // Center the canvas wrapper
            // Since transform-origin is center center, we just need to ensure the wrapper is centered in the flex container
            // The flex container (canvas-container) already does this with justify-center items-center

            // However, we need to make sure the canvas wrapper has the correct size for the transform
            // Actually, we are transforming detailCanvas directly. 
            // Let's reset position to 0,0 for centering
            // And ensure the canvas is positioned relatively or absolutely correctly.
            // In the HTML update, I set detailCanvas to absolute.
            // With flex center, it should be centered.

            // Update UI
            updateDetailEditorUI();
            updateNavigationButtons();

            // Initialize with Dark background pattern (default)
            setBackgroundPattern('dark');

            // Only set default tool on first use
            if (!currentTool) {
                switchTool('magicWand');
            } else {
                // Keep current tool but update UI
                updateDetailEditorUI();
            }
        }

        function closeDetailEditor() {
            detailEditor.classList.add('hidden');
            currentEditingIndex = -1;

            // Update main grid with edited images
            updateGrid();
        }

        function handleDetailMouseDown(e) {
            if (isHandToolActive) return; // Skip if panning

            isDrawing = true;
        }

        function saveDetailHistory() {
            if (isHandToolActive) return; // Prevent tool action if Hand Tool is active
            if (currentEditingIndex === -1) return;

            const state = cellEditorStates[currentEditingIndex];
            // Remove future history if we're not at the end
            if (state.historyIndex < state.history.length - 1) {
                state.history = state.history.slice(0, state.historyIndex + 1);
            }

            // Add new state
            const imageData = detailCtx.getImageData(0, 0, detailCanvas.width, detailCanvas.height);
            state.history.push({
                imageData: imageData,
                position: { ...state.position }
            });
            state.historyIndex = state.history.length - 1;

            // Limit history to 20
            if (state.history.length > 20) {
                state.history.shift();
                state.historyIndex--;
            }

            updateDetailHistoryButtons();
        }

        function detailUndo() {
            if (currentEditingIndex === -1) return;
            const state = cellEditorStates[currentEditingIndex];

            if (state.historyIndex > 0) {
                state.historyIndex--;
                const historyState = state.history[state.historyIndex];
                detailCtx.putImageData(historyState.imageData, 0, 0);
                state.position = { ...historyState.position };
                state.imageData = detailCtx.getImageData(0, 0, detailCanvas.width, detailCanvas.height);
                updateDetailHistoryButtons();
                updatePositionDisplay();
            }
        }

        function detailRedo() {
            if (currentEditingIndex === -1) return;
            const state = cellEditorStates[currentEditingIndex];

            if (state.historyIndex < state.history.length - 1) {
                state.historyIndex++;
                const historyState = state.history[state.historyIndex];
                detailCtx.putImageData(historyState.imageData, 0, 0);
                state.position = { ...historyState.position };
                state.imageData = detailCtx.getImageData(0, 0, detailCanvas.width, detailCanvas.height);
                updateDetailHistoryButtons();
                updatePositionDisplay();
            }
        }

        function detailReset() {
            if (currentEditingIndex === -1) return;
            if (!confirm('すべての編集をリセットしますか？')) return;

            // Re-extract from main canvas
            const cols = parseInt(colInput.value);
            const rows = parseInt(rowInput.value);
            const c = currentEditingIndex % cols;
            const r = Math.floor(currentEditingIndex / cols);
            const cellW = editorCanvas.width / cols;
            const cellH = editorCanvas.height / rows;

            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = SPECS.sticker.w;
            tempCanvas.height = SPECS.sticker.h;
            const tempCtx = tempCanvas.getContext('2d', { willReadFrequently: true });
            tempCtx.drawImage(editorCanvas, c * cellW, r * cellH, cellW, cellH, 0, 0, SPECS.sticker.w, SPECS.sticker.h);

            cellEditorStates[currentEditingIndex] = {
                imageData: tempCtx.getImageData(0, 0, SPECS.sticker.w, SPECS.sticker.h),
                position: { x: 0, y: 0 },
                history: [],
                historyIndex: -1
            };

            detailCtx.putImageData(cellEditorStates[currentEditingIndex].imageData, 0, 0);
            saveDetailHistory();
            updateDetailHistoryButtons();
            updatePositionDisplay();
        }

        function updateDetailHistoryButtons() {
            if (currentEditingIndex === -1) return;
            const state = cellEditorStates[currentEditingIndex];
            detailUndoBtn.disabled = state.historyIndex <= 0;
            detailRedoBtn.disabled = state.historyIndex >= state.history.length - 1;
        }

        function updateNavigationButtons() {
            const cols = parseInt(colInput.value);
            const rows = parseInt(rowInput.value);
            const total = cols * rows;

            // Find previous checked cell
            let prevIndex = -1;
            for (let i = currentEditingIndex - 1; i >= 0; i--) {
                if (cellCheckStates[i]) {
                    prevIndex = i;
                    break;
                }
            }

            // Find next checked cell
            let nextIndex = -1;
            for (let i = currentEditingIndex + 1; i < total; i++) {
                if (cellCheckStates[i]) {
                    nextIndex = i;
                    break;
                }
            }

            prevImageBtn.disabled = prevIndex === -1;
            nextImageBtn.disabled = nextIndex === -1;
        }

        function navigateToPrev() {
            const cols = parseInt(colInput.value);

            for (let i = currentEditingIndex - 1; i >= 0; i--) {
                if (cellCheckStates[i]) {
                    // Save current state
                    if (currentEditingIndex !== -1) {
                        cellEditorStates[currentEditingIndex].imageData = detailCtx.getImageData(0, 0, detailCanvas.width, detailCanvas.height);
                    }
                    openDetailEditor(i);
                    return;
                }
            }
        }

        function navigateToNext() {
            const cols = parseInt(colInput.value);
            const rows = parseInt(rowInput.value);
            const total = cols * rows;

            for (let i = currentEditingIndex + 1; i < total; i++) {
                if (cellCheckStates[i]) {
                    // Save current state
                    if (currentEditingIndex !== -1) {
                        cellEditorStates[currentEditingIndex].imageData = detailCtx.getImageData(0, 0, detailCanvas.width, detailCanvas.height);
                    }
                    openDetailEditor(i);
                    return;
                }
            }
        }

        function switchTool(tool) {
            currentTool = tool;
            updateDetailEditorUI();
        }

        function updateDetailEditorUI() {
            // Update tool buttons
            if (currentTool === 'move') {
                toolMoveBtn.classList.add('border-green-500');
                toolMoveBtn.classList.remove('border-gray-300');
                toolBrushBtn.classList.remove('border-green-500');
                toolBrushBtn.classList.add('border-gray-300');
                toolMagicWandBtn.classList.remove('border-green-500');
                toolMagicWandBtn.classList.add('border-gray-300');
                brushSizePanel.classList.add('hidden');
                brushModePanel.classList.add('hidden');
                positionPanel.classList.remove('hidden');
                detailCanvas.style.cursor = 'move';
            } else if (currentTool === 'brush') {
                toolBrushBtn.classList.add('border-green-500');
                toolBrushBtn.classList.remove('border-gray-300');
                toolMoveBtn.classList.remove('border-green-500');
                toolMoveBtn.classList.add('border-gray-300');
                toolMagicWandBtn.classList.remove('border-green-500');
                toolMagicWandBtn.classList.add('border-gray-300');
                brushSizePanel.classList.remove('hidden');
                brushModePanel.classList.remove('hidden');
                positionPanel.classList.add('hidden');
                updateBrushCursor();
            } else if (currentTool === 'magicWand') {
                toolMagicWandBtn.classList.add('border-green-500');
                toolMagicWandBtn.classList.remove('border-gray-300');
                toolBrushBtn.classList.remove('border-green-500');
                toolBrushBtn.classList.add('border-gray-300');
                toolMoveBtn.classList.remove('border-green-500');
                toolMoveBtn.classList.add('border-gray-300');
                brushSizePanel.classList.add('hidden');
                brushModePanel.classList.add('hidden');
                positionPanel.classList.add('hidden');
                detailCanvas.style.cursor = 'crosshair';
            }

            updatePositionDisplay();
            updateDetailHistoryButtons();

            // Show/Hide Center Grid
            if (currentTool === 'move') {
                centerGrid.classList.remove('hidden');
            } else {
                centerGrid.classList.add('hidden');
            }
        }

        function updatePositionDisplay() {
            if (currentEditingIndex === -1) return;
            const state = cellEditorStates[currentEditingIndex];
            posXDisplay.innerText = Math.round(state.position.x);
            posYDisplay.innerText = Math.round(state.position.y);
        }

        function centerPosition() {
            if (currentEditingIndex === -1) return;
            const state = cellEditorStates[currentEditingIndex];
            state.position = { x: 0, y: 0 };
            updatePositionDisplay();
            redrawCanvas(currentEditingIndex);
            saveDetailHistory();
        }

        function setZoom(zoom) {
            currentZoom = zoom;

            // Update slider if needed (e.g. when called programmatically)
            const zoomSlider = document.getElementById('zoomSlider');
            const zoomValue = document.getElementById('zoomValue');
            if (zoomSlider && zoomValue) {
                zoomSlider.value = Math.round(zoom * 100);
                zoomValue.textContent = `${Math.round(zoom * 100)}%`;
            }

            // Update zoom buttons
            document.querySelectorAll('.zoom-btn').forEach(btn => {
                if (parseFloat(btn.dataset.zoom) === zoom) {
                    btn.classList.add('border-green-500');
                    btn.classList.remove('border-gray-300');
                } else {
                    btn.classList.remove('border-green-500');
                    btn.classList.add('border-gray-300');
                }
            });

            // Apply zoom transform
            detailCanvas.style.transform = `scale(${zoom})`;
            detailCanvas.style.transformOrigin = 'top left';

            // Apply to wrapper as well
            const wrapper = document.getElementById('detailCanvasWrapper');
            if (wrapper) {
                wrapper.style.transform = `scale(${zoom})`;
                wrapper.style.transformOrigin = 'top left';
            }

            // Resize zoomWrapper to trigger scrollbars
            const zoomWrapper = document.getElementById('zoomWrapper');
            if (zoomWrapper) {
                zoomWrapper.style.width = `${detailCanvas.width * zoom}px`;
                zoomWrapper.style.height = `${detailCanvas.height * zoom}px`;
            }
        }

        // --- Hand Tool & Pan Logic ---
        const handToolBtn = document.getElementById('handToolBtn');
        let isHandToolActive = false;
        // isPanning is already declared globally
        let startPanX = 0;
        let startPanY = 0;
        let scrollStartX = 0;
        let scrollStartY = 0;

        if (handToolBtn) {
            handToolBtn.addEventListener('click', () => {
                isHandToolActive = !isHandToolActive;
                updateHandToolUI();
            });
        }

        function updateHandToolUI() {
            if (isHandToolActive) {
                handToolBtn.classList.add('bg-green-100', 'text-green-600', 'border-green-500');
                detailCanvas.style.cursor = 'grab';
            } else {
                handToolBtn.classList.remove('bg-green-100', 'text-green-600', 'border-green-500');
                updateCursor(); // Restore tool cursor
            }
        }

        function updateCursor() {
            if (isHandToolActive) {
                detailCanvas.style.cursor = 'grab';
            } else if (currentTool === 'move') {
                detailCanvas.style.cursor = 'move';
            } else if (currentTool === 'brush') {
                updateBrushCursor();
            } else if (currentTool === 'magicWand') {
                detailCanvas.style.cursor = 'crosshair';
            }
        }

        const detailContainer = detailEditor.querySelector('.canvas-container');

        detailContainer.addEventListener('mousedown', (e) => {
            if (isHandToolActive) {
                isPanning = true;
                detailCanvas.style.cursor = 'grabbing';
                startPanX = e.clientX;
                startPanY = e.clientY;
                scrollStartX = detailContainer.scrollLeft;
                scrollStartY = detailContainer.scrollTop;
                e.preventDefault(); // Prevent text selection
            }
        });

        window.addEventListener('mousemove', (e) => {
            if (isPanning && isHandToolActive) {
                const dx = e.clientX - startPanX;
                const dy = e.clientY - startPanY;
                detailContainer.scrollLeft = scrollStartX - dx;
                detailContainer.scrollTop = scrollStartY - dy;
            }
        });

        window.addEventListener('mouseup', () => {
            if (isPanning) {
                isPanning = false;
                if (isHandToolActive) detailCanvas.style.cursor = 'grab';
            }
        });

        // --- Background Pattern Persistence ---
        // currentBgPattern is already declared globally

        function setBackgroundPattern(pattern) {
            currentBgPattern = pattern; // Update current pattern

            // Update buttons UI
            document.querySelectorAll('.bg-pattern-btn').forEach(btn => {
                if (btn.dataset.pattern === pattern) {
                    btn.classList.add('border-green-500');
                    btn.classList.remove('border-gray-300');
                } else {
                    btn.classList.remove('border-green-500');
                    btn.classList.add('border-gray-300');
                }
            });

            // Update canvas background
            const wrapper = document.getElementById('detailCanvasWrapper');
            wrapper.className = 'relative'; // Reset

            if (pattern === 'transparent') {
                wrapper.style.backgroundImage = 'linear-gradient(45deg, #ccc 25%, transparent 25%), linear-gradient(-45deg, #ccc 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #ccc 75%), linear-gradient(-45deg, transparent 75%, #ccc 75%)';
                wrapper.style.backgroundSize = '20px 20px';
                wrapper.style.backgroundPosition = '0 0, 0 10px, 10px -10px, -10px 0px';
                wrapper.style.backgroundColor = 'white';
            } else if (pattern === 'dark') {
                // Dark checkerboard
                wrapper.style.backgroundImage = 'linear-gradient(45deg, #333 25%, transparent 25%), linear-gradient(-45deg, #333 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #333 75%), linear-gradient(-45deg, transparent 75%, #333 75%)';
                wrapper.style.backgroundSize = '20px 20px';
                wrapper.style.backgroundPosition = '0 0, 0 10px, 10px -10px, -10px 0px';
                wrapper.style.backgroundColor = '#1a1a1a';
            } else if (pattern === 'normal') {
                wrapper.style.background = '#8fb4d8'; // LINE default blue
                wrapper.style.backgroundImage = 'none';
            }
        }

        function updateBrushCursor() {
            // Create dynamic circular cursor based on brush size
            const size = Math.max(16, Math.min(brushSize * 2, 64)); // Clamp size for visibility
            const cursorSvg = `data:image/svg+xml,${encodeURIComponent(
                `<svg xmlns='http://www.w3.org/2000/svg' width='${size}' height='${size}' viewBox='0 0 ${size} ${size}'><circle cx='${size / 2}' cy='${size / 2}' r='${size / 2 - 1}' stroke='black' stroke-width='2' fill='none'/><circle cx='${size / 2}' cy='${size / 2}' r='${size / 2 - 1}' stroke='white' stroke-width='1' fill='none'/></svg>`
            )}`;
            detailCanvas.style.cursor = `url("${cursorSvg}") ${size / 2} ${size / 2}, crosshair`;
        }

        // Event Listeners for Detail Editor
        toolMoveBtn?.addEventListener('click', () => switchTool('move'));
        toolBrushBtn?.addEventListener('click', () => switchTool('brush'));
        toolMagicWandBtn?.addEventListener('click', () => switchTool('magicWand'));

        brushSizeSlider?.addEventListener('input', (e) => {
            brushSize = parseInt(e.target.value);
            brushSizeVal.innerText = brushSize;
            // Update cursor if brush tool is active
            if (currentTool === 'brush') {
                updateBrushCursor();
            }
        });

        document.querySelectorAll('input[name="brushMode"]').forEach(radio => {
            radio.addEventListener('change', (e) => {
                brushMode = e.target.value;
            });
        });

        // Zoom Slider
        const zoomSlider = document.getElementById('zoomSlider');
        if (zoomSlider) {
            zoomSlider.addEventListener('input', (e) => {
                const zoom = parseInt(e.target.value) / 100;
                setZoom(zoom);
            });
        }

        // Zoom Buttons
        document.querySelectorAll('.zoom-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                setZoom(parseFloat(btn.dataset.zoom));
            });
        });

        // Trackpad Panning (Wheel event) - Removed custom panning to allow native scrollbars
        detailContainer.addEventListener('wheel', (e) => {
            if (e.ctrlKey) {
                e.preventDefault();
                const delta = -e.deltaY;
                const step = 0.1;
                let newZoom = currentZoom + (delta > 0 ? step : -step);
                newZoom = Math.max(1, Math.min(5, newZoom)); // 100% to 500%
                setZoom(newZoom);
            }
            // Normal scrolling is handled natively by overflow: auto
        }, { passive: false });

        // Background Pattern Buttons
        document.querySelectorAll('.bg-pattern-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                setBackgroundPattern(btn.dataset.pattern);
            });
        });

        centerBtn?.addEventListener('click', centerPosition);
        detailUndoBtn?.addEventListener('click', detailUndo);
        detailRedoBtn?.addEventListener('click', detailRedo);
        detailResetBtn?.addEventListener('click', detailReset);
        prevImageBtn?.addEventListener('click', navigateToPrev);
        nextImageBtn?.addEventListener('click', navigateToNext);
        closeEditorBtn?.addEventListener('click', () => {
            // Save current state before closing
            if (currentEditingIndex !== -1) {
                cellEditorStates[currentEditingIndex].imageData = detailCtx.getImageData(0, 0, detailCanvas.width, detailCanvas.height);
            }
            closeDetailEditor();
        });

        // Robust coordinate calculation helper
        function getCanvasCoordinates(e, canvas) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            return {
                x: (e.clientX - rect.left) * scaleX,
                y: (e.clientY - rect.top) * scaleY
            };
        }

        // Canvas interaction for detail editor
        // Helper to redraw canvas from state (Non-destructive)
        function redrawCanvas(index) {
            if (index === -1 || !cellEditorStates[index]) return;

            const state = cellEditorStates[index];
            const imgData = state.imageData;

            // Clear canvas
            detailCtx.clearRect(0, 0, detailCanvas.width, detailCanvas.height);

            // Create a temporary canvas to hold the image data
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = detailCanvas.width;
            tempCanvas.height = detailCanvas.height;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.putImageData(imgData, 0, 0);

            // Draw the temporary canvas onto the detail canvas at the specified position
            detailCtx.drawImage(tempCanvas, state.position.x, state.position.y);
        }

        // Canvas interaction for detail editor
        detailCanvas?.addEventListener('mousedown', (e) => {
            const coords = getCanvasCoordinates(e, detailCanvas);
            const x = coords.x;
            const y = coords.y;

            if (currentTool === 'move') {
                isDragging = true;
                dragStart = { x: x, y: y };
                // Non-destructive: No need to capture image data here
            } else if (currentTool === 'brush') {
                applyBrush(x, y);
                isDragging = true;
            } else if (currentTool === 'magicWand') {
                const tolerance = parseInt(toleranceRange.value);
                floodFill(Math.floor(x), Math.floor(y), tolerance, detailCtx, detailCanvas.width, detailCanvas.height);
                saveDetailHistory();
            }
        });



        detailCanvas?.addEventListener('mousemove', (e) => {
            if (!isDragging) return;

            const coords = getCanvasCoordinates(e, detailCanvas);
            const x = coords.x;
            const y = coords.y;

            if (currentTool === 'move') {
                // Non-Destructive Move
                const dx = x - dragStart.x;
                const dy = y - dragStart.y;

                // Update position in state
                const state = cellEditorStates[currentEditingIndex];
                state.position.x += dx;
                state.position.y += dy;

                // Redraw
                redrawCanvas(currentEditingIndex);

                // Update drag start for next frame (continuous delta)
                dragStart = { x: x, y: y };

                // Update display
                posXDisplay.innerText = Math.round(state.position.x);
                posYDisplay.innerText = Math.round(state.position.y);

            } else if (currentTool === 'brush') {
                applyBrush(x, y);
            }
        });

        detailCanvas?.addEventListener('mouseup', () => {
            if (isDragging && currentEditingIndex !== -1) {
                if (currentTool === 'move') {
                    // Save the baked change
                    saveDetailHistory();
                    // Reset drag state
                    dragStartImageData = null;
                } else {
                    saveDetailHistory();
                }
            }
            isDragging = false;
        });

        detailCanvas?.addEventListener('mouseleave', () => {
            if (isDragging && currentEditingIndex !== -1) {
                if (currentTool === 'move') {
                    // Save the baked change
                    saveDetailHistory();
                    // Reset drag state
                    dragStartImageData = null;
                } else {
                    saveDetailHistory();
                }
            }
            isDragging = false;
        });

        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            if (detailEditor.classList.contains('hidden')) return;

            // Tool shortcuts
            if (e.key === 'v' || e.key === 'V') {
                switchTool('move');
                e.preventDefault();
            } else if (e.key === 'b' || e.key === 'B') {
                switchTool('brush');
                e.preventDefault();
            } else if (e.key === 'w' || e.key === 'W') {
                switchTool('magicWand');
                e.preventDefault();
            }

            // Undo/Redo shortcuts
            if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
                detailUndo();
                e.preventDefault();
            } else if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {
                detailRedo();
                e.preventDefault();
            }

            // Arrow key movement (only in move tool)
            if (currentTool === 'move' && currentEditingIndex !== -1) {
                const state = cellEditorStates[currentEditingIndex];
                const step = e.shiftKey ? 10 : 1;
                let moved = false;

                if (e.key === 'ArrowLeft') {
                    state.position.x -= step;
                    moved = true;
                } else if (e.key === 'ArrowRight') {
                    state.position.x += step;
                    moved = true;
                } else if (e.key === 'ArrowUp') {
                    state.position.y -= step;
                    moved = true;
                } else if (e.key === 'ArrowDown') {
                    state.position.y += step;
                    moved = true;
                }

                if (moved) {
                    updatePositionDisplay();
                    e.preventDefault();
                }
            }
        });

        // Release arrow keys to save history
        document.addEventListener('keyup', (e) => {
            if (detailEditor.classList.contains('hidden')) return;
            if (currentTool === 'move' && currentEditingIndex !== -1) {
                if (['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown'].includes(e.key)) {
                    saveDetailHistory();
                }
            }
        });

        function applyBrush(x, y) {
            if (!detailCtx || currentEditingIndex === -1) return;

            const imageData = detailCtx.getImageData(0, 0, detailCanvas.width, detailCanvas.height);
            const data = imageData.data;

            // Circular brush
            for (let dy = -brushSize; dy <= brushSize; dy++) {
                for (let dx = -brushSize; dx <= brushSize; dx++) {
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist > brushSize) continue;

                    const px = Math.floor(x + dx);
                    const py = Math.floor(y + dy);

                    if (px < 0 || px >= detailCanvas.width || py < 0 || py >= detailCanvas.height) continue;

                    const idx = (py * detailCanvas.width + px) * 4;

                    if (brushMode === 'erase') {
                        data[idx + 3] = 0; // Set alpha to 0
                    } else if (brushMode === 'restore') {
                        // Restore from ORIGINAL image data
                        const state = cellEditorStates[currentEditingIndex];
                        if (state.originalImageData) {
                            const originalData = state.originalImageData.data;
                            data[idx] = originalData[idx];
                            data[idx + 1] = originalData[idx + 1];
                            data[idx + 2] = originalData[idx + 2];
                            data[idx + 3] = originalData[idx + 3];
                        }
                    }
                }
            }

            detailCtx.putImageData(imageData, 0, 0);
            cellEditorStates[currentEditingIndex].imageData = imageData;
        }



        // ===== LINE PREVIEW FUNCTIONS =====

        let currentPreviewBg = 'dark'; // Default background

        function showLinePreview(stickerDataURLs) {
            const linePreview = document.getElementById('linePreview');
            const chatMessages = document.getElementById('chatMessages');

            // Clear previous messages
            chatMessages.innerHTML = '';

            // Create sample chat messages with stickers
            const messages = [
                { type: 'text', content: 'Hello', isUser: true },
            ];

            // Add stickers (show up to 5 for preview)
            const stickersToShow = stickerDataURLs.slice(0, Math.min(5, stickerDataURLs.length));
            stickersToShow.forEach((stickerURL, index) => {
                messages.push({ type: 'sticker', content: stickerURL, isUser: index % 2 === 0 });
            });

            // Render messages
            messages.forEach(msg => {
                const messageDiv = document.createElement('div');
                messageDiv.className = `flex ${msg.isUser ? 'justify-start' : 'justify-end'}`;

                if (msg.type === 'text') {
                    const bubble = document.createElement('div');
                    bubble.className = `px-3 py-2 rounded-2xl max-w-xs ${msg.isUser
                        ? 'bg-white text-gray-800'
                        : 'bg-green-500 text-white'
                        }`;
                    bubble.textContent = msg.content;

                    const wrapper = document.createElement('div');
                    wrapper.className = 'flex items-end gap-2';

                    if (msg.isUser) {
                        // Add avatar
                        const avatar = document.createElement('div');
                        avatar.className = 'w-10 h-10 rounded-full bg-green-500 flex-shrink-0 flex items-center justify-center';
                        avatar.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2"><circle cx="12" cy="12" r="10"/><path d="M8 12h8M12 8v8"/></svg>`;
                        wrapper.appendChild(avatar);
                    }

                    wrapper.appendChild(bubble);
                    messageDiv.appendChild(wrapper);
                } else if (msg.type === 'sticker') {
                    const stickerImg = document.createElement('img');
                    stickerImg.src = msg.content;
                    stickerImg.className = 'max-w-[150px] max-h-[150px]';
                    stickerImg.style.imageRendering = 'crisp-edges';

                    const wrapper = document.createElement('div');
                    wrapper.className = 'flex items-end gap-2';

                    if (msg.isUser) {
                        // Add avatar
                        const avatar = document.createElement('div');
                        avatar.className = 'w-10 h-10 rounded-full bg-green-500 flex-shrink-0 flex items-center justify-center';
                        avatar.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2"><circle cx="12" cy="12" r="10"/><path d="M8 12h8M12 8v8"/></svg>`;
                        wrapper.appendChild(avatar);
                    }

                    wrapper.appendChild(stickerImg);
                    messageDiv.appendChild(wrapper);
                }

                chatMessages.appendChild(messageDiv);
            });

            // Show preview section
            linePreview.classList.remove('hidden');
            linePreview.scrollIntoView({ behavior: 'smooth', block: 'nearest' });

            // Set initial background
            setBackgroundPattern(currentBgPattern);
        }

        function setPreviewBackground(bg) {
            currentPreviewBg = bg;
            const chatContainer = document.getElementById('chatContainer');
            const chatMessages = document.getElementById('chatMessages');

            // Update button states
            document.querySelectorAll('.preview-bg-btn').forEach(btn => {
                if (btn.dataset.bg === bg) {
                    btn.classList.add('border-green-500');
                    btn.classList.remove('border-gray-300');
                } else {
                    btn.classList.remove('border-green-500');
                    btn.classList.add('border-gray-300');
                }
            });

            // Apply background styles
            switch (bg) {
                case 'light':
                    chatContainer.style.background = '#ffffff';
                    chatMessages.style.background = '#ffffff';
                    break;
                case 'normal':
                    chatContainer.style.background = '#8fb4d8';
                    chatMessages.style.background = '#8fb4d8';
                    break;
                case 'dark':
                    chatContainer.style.background = '#1a1a1a';
                    chatMessages.style.background = '#1a1a1a';
                    break;
            }
        }

        // Event listeners for preview background buttons
        document.querySelectorAll('.preview-bg-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                setPreviewBackground(btn.dataset.bg);
            });
        });

        // ===== DETAIL EDITOR PREVIEW MODAL =====

        const detailPreviewModal = document.getElementById('detailPreviewModal');
        const showDetailPreviewBtn = document.getElementById('showDetailPreviewBtn');
        const closeDetailPreviewBtn = document.getElementById('closeDetailPreviewBtn');
        let currentMobilePreviewBg = 'normal';

        function showDetailPreview() {
            if (!detailCtx || currentEditingIndex === -1) {
                alert('スティッカーを編集してください');
                return;
            }

            // Get current sticker as data URL
            const stickerDataURL = detailCanvas.toDataURL();

            // Populate mobile preview
            populateMobilePreview(stickerDataURL, currentMobilePreviewBg);

            // Show modal
            detailPreviewModal.classList.remove('hidden');
        }

        function populateMobilePreview(stickerDataURL, bgType) {
            const container = document.getElementById('previewChatMobile');
            if (!container) return;

            // Set background
            switch (bgType) {
                case 'light':
                    container.style.background = '#ffffff';
                    break;
                case 'normal':
                    container.style.background = '#8fb4d8';
                    break;
                case 'dark':
                    container.style.background = '#1a1a1a';
                    break;
            }

            // Clear previous content
            container.innerHTML = '';

            // Create sample messages
            const messages = [
                { type: 'text', content: 'Hello', isUser: true },
                { type: 'sticker', content: stickerDataURL, isUser: true },
                { type: 'sticker', content: stickerDataURL, isUser: false },
            ];

            messages.forEach(msg => {
                const messageDiv = document.createElement('div');
                messageDiv.className = `flex ${msg.isUser ? 'justify-start' : 'justify-end'}`;

                if (msg.type === 'text') {
                    const bubble = document.createElement('div');
                    bubble.className = `px-3 py-2 rounded-2xl text-sm ${msg.isUser
                        ? 'bg-white text-gray-800'
                        : 'bg-green-500 text-white'
                        }`;
                    bubble.textContent = msg.content;

                    const wrapper = document.createElement('div');
                    wrapper.className = 'flex items-end gap-2';

                    if (msg.isUser) {
                        const avatar = document.createElement('div');
                        avatar.className = 'w-8 h-8 rounded-full bg-green-500 flex-shrink-0 flex items-center justify-center';
                        avatar.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2"><circle cx="12" cy="12" r="10"/></svg>`;
                        wrapper.appendChild(avatar);
                    }

                    wrapper.appendChild(bubble);
                    messageDiv.appendChild(wrapper);
                } else if (msg.type === 'sticker') {
                    const stickerImg = document.createElement('img');
                    stickerImg.src = msg.content;
                    stickerImg.className = 'max-w-[150px] max-h-[150px]';
                    stickerImg.style.imageRendering = 'crisp-edges';

                    const wrapper = document.createElement('div');
                    wrapper.className = 'flex items-end gap-2';

                    if (msg.isUser) {
                        const avatar = document.createElement('div');
                        avatar.className = 'w-8 h-8 rounded-full bg-green-500 flex-shrink-0 flex items-center justify-center';
                        avatar.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2"><circle cx="12" cy="12" r="10"/></svg>`;
                        wrapper.appendChild(avatar);
                    }

                    wrapper.appendChild(stickerImg);
                    messageDiv.appendChild(wrapper);
                }

                container.appendChild(messageDiv);
            });
        }

        function switchMobilePreviewBg(bgType) {
            currentMobilePreviewBg = bgType;

            // Update button states
            document.querySelectorAll('.preview-switch-btn').forEach(btn => {
                if (btn.dataset.bg === bgType) {
                    btn.classList.add('border-green-500');
                    btn.classList.remove('border-gray-300');
                } else {
                    btn.classList.remove('border-green-500');
                    btn.classList.add('border-gray-300');
                }
            });

            // Regenerate preview with new background
            if (!detailCtx || currentEditingIndex === -1) return;
            const stickerDataURL = detailCanvas.toDataURL();
            populateMobilePreview(stickerDataURL, bgType);
        }

        function closeDetailPreview() {
            detailPreviewModal.classList.add('hidden');
        }

        // Event listeners for detail preview modal
        showDetailPreviewBtn?.addEventListener('click', showDetailPreview);
        closeDetailPreviewBtn?.addEventListener('click', closeDetailPreview);

        // Background switcher buttons
        document.querySelectorAll('.preview-switch-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                switchMobilePreviewBg(btn.dataset.bg);
            });
        });

        // Close modal on background click
        detailPreviewModal?.addEventListener('click', (e) => {
            if (e.target === detailPreviewModal) {
                closeDetailPreview();
            }
        });
    </script>
</body>

</html>